1 Introduction:
There have recently been a lot of interesting contributions to the issue of style transfer using deep neural networks. Gatys et al. [3] proposed a novel approach using neural networks to capture the style of artistic images and transfer it to real world photographs. Their approach uses high-level feature representations of the images from hidden layers of the VGG convolutional network [10] to separate and reassemble content and style. This is done by formulating an optimization problem that, starting with white noise, searches for a new image showing similar neural activations as the content image and similar feature correlations (expressed by a Gram matrix) as the style image. The present paper builds upon the approach from Gatys et al. [3] and extends style transfer to video sequences. Given an artistic image, we transfer its particular style of painting to the entire video. Processing each frame of the video independently leads to flickering and false discontinuities, since the solution of the style transfer task is not stable. To regularize the transfer and to preserve smooth transition between individual frames of the video, we introduce a temporal constraint that penalizes deviations between two frames. The temporal constraint takes the optical flow from the original video into account: instead of penalizing the deviations from the previous frame, we penalize deviation along the point trajectories. Disoccluded regions as well as motion boundaries are excluded from the penalizer. This allows the process to rebuild disoccluded regions and distorted motion boundaries while preserving the appearance of the rest of the image, see Fig. 1. In addition, we present two extensions of our approach. The first one aims on improving the consistency over larger periods of time. When a region that is occluded in some frame and disoccluded later gets rebuilt during the process, most likely this region will have a different appearance than before the occlusion. To solve this, we make use of long term motion estimates. This allows us to enforce consistency of the synthesized frames before and after the occlusion. Secondly, the style transfer tends to create artifacts at the image boundaries. For static images, these artifacts are hardly visible, yet for videos with strong camera motion they move towards the center of the image and get amplified. We developed a multi-pass algorithm, which processes the video in alternating directions using both forward and backward flow. This results in a more coherent video. We quantitatively evaluated our approach in combination with different optical flow algorithms on the Sintel benchmark. Additionally we show qualitative results on several movie shots. We were able to successfully eliminate most of the temporal artifacts and can create smooth and coherent stylized videos. Fig. 1.Scene from Ice Age (2002) processed in the style of The Starry Night. Comparing independent per-frame processing to our time consistent approach, the latter is clearly preferable. Best observed in the supplemental video, see Sect. 8.1. 


2 Related Work:

Style transfer using deep networks: Gatys et al. [3] showed remarkable results by using the VGG-19 deep neural network for style transfer. Their approach was taken up by various follow-up papers that, among other things, proposed different ways to represent the style within the neural network. Li et al. [5] suggested an approach to preserve local patterns of the style image. Instead of using a global representation of the style, computed as Gram matrix, they used patches of the neural activation from the style image. Nikulin et al. [7] tried the style transfer algorithm by Gatys et al. on other nets than VGG and proposed several variations in the way the style of the image is represented to archive different goals like illumination or season transfer. However, we are not aware of any work that applies this kind of style transfer to videos. 
Painted animations: One common approach to create video sequences with an artistic style is to generate artificial brush strokes to repaint the scene. Different artistic styles are gained by modifying various parameters of these brush strokes, like thickness, or by using different brush placement methods. To achieve temporal consistency Litwinowicz [6] was one of the first who used optical flow. In his approach, brush strokes were generated for the first frame and then moved along the flow field. Later, this approach was refined. Hays et al. [4] proposed new stylistic parameters for the brush strokes to mimic different artistic styles. O’Donovan et al. [8] formulated an energy optimization problem for an optimal placement and shape of the brush strokes and also integrated a temporal constraint into the optimization problem by penalizing changes in shape and width of the brush strokes compared to the previous frame. These approaches are similar in spirit to what we are doing, but they are only capable of applying a restricted class of artistic styles. 

3 Style Transfer in Still Images:
In this section, we briefly review the style transfer approach introduced by Gatys et al. [3]. The aim is to generate a stylized image  showing the content of an image  in the style of an image . Gatys et al. formulated an energy minimization problem consisting of a content loss and a style loss. The key idea is that features extracted by a convolutional network carry information about the content of the image, while the correlations of these features encode the style. We denote by  the function implemented by the part of the convolutional network from input up to the layer l. The feature maps extracted by the network from the original image , the style image  and the stylized image  we denote by ,  and  respectively. The dimensionality of these feature maps we denote by , where  is the number of filters (channels) in the layer, and  is the spatial dimensionality of the feature map, that is, the product of its width and height. The content loss, denoted as , is simply the mean squared error between  and . This loss need not be restricted to only one layer. Let  be the set of layers to be used for content representation, then we have: 
(1)
The style loss is also a mean squared error, but between the correlations of the filter responses expressed by their Gram matrices  for the style image  and  for the stylized image . These are computed as  and . As above, let  be the set of layers we use to represent the style, then the style loss is given by: 
(2)
Overall, the loss function is given by 
(3)
with weighting factors  and  governing the importance of the two components. The stylized image is computed by minimizing this energy with respect to  using gradient-based optimization. Typically it is initialized with random Gaussian noise. However, the loss function is non-convex, therefore the optimization is prone to falling into local minima. This makes the initialization of the stylized image important, especially when applying the method to frames of a video. 

4 Style Transfer in Videos:
We use the following notation:  is the  frame of the original video,  is the style image and  are the stylized frames to be generated. Furthermore, we denote by  the initialization of the style optimization algorithm at frame i. By  we denote the  component of a vector . 

4.1 Short-term Consistency by Initialization:
When the style transfer for consecutive frames is initialized by independent Gaussian noise, two frames of a video converge to very different local minima, resulting in a strong flickering. The most basic way to yield temporal consistency is to initialize the optimization for the frame  with the stylized frame i. Areas that have not changed between the two frames are then initialized with the desired appearance, while the rest of the image has to be rebuilt through the optimization process. If there is motion in the scene, this simple approach does not perform well, since moving objects are initialized incorrectly. Thus, we take the optical flow into account and initialize the optimization for the frame  with the previous stylized frame warped: . Here  denotes the function that warps a given image using the optical flow field that was estimated between image  and . Clearly, the first frame of the stylized video still has to be initialized randomly. We experimented with two state-of-the-art optical flow estimation algorithms: DeepFlow [12] and EpicFlow [9]. Both are based on Deep Matching [12]: DeepFlow combines it with a variational approach, while EpicFlow relies on edge-preserving sparse-to-dense interpolation. 

4.2 Temporal Consistency Loss:
To enforce stronger consistency between adjacent frames we additionally introduce an explicit consistency penalty to the loss function. This requires detection of disoccluded regions and motion boundaries. To detect disocclusions, we perform a forward-backward consistency check of the optical flow [11]. Let  be the optical flow in forward direction and  the flow in backward direction. Denote by  the forward flow warped to the second image: 
(4)
In areas without disocclusion, this warped flow should be approximately the opposite of the backward flow. Therefore we mark as disocclusions those areas where the following inequality holds: 
(5)
Motion boundaries are detected using the following inequality: 
(6)
Coefficients in inequalities (5) and (6) are taken from Sundaram et al. [11]. The temporal consistency loss function penalizes deviations from the warped image in regions where the optical flow is consistent and estimated with high confidence: \begin{aligned} \mathcal {L}_{temporal}(\varvec{x}, \varvec{\omega }, \varvec{c}) = \frac{1}{D} \sum _{k=1}^D c_k \cdot (x_k - \omega _k)^2. \end{aligned}
(7)
Here \varvec{c}\in [0, 1]^D is per-pixel weighting of the loss and D = W \times H \times C is the dimensionality of the image. We define the weights \varvec{c}^{(i-1,i)} between frames i\!-\!1 and i as follows: 0 in disoccluded regions (as detected by forward-backward consistency) and at the motion boundaries, and 1 everywhere else. Potentially weights between 0 and 1 could be used to incorporate the certainty of the optical flow prediction. The overall loss takes the form: \begin{aligned} \mathcal {L}_{shortterm}\bigl (\varvec{p}^{(i)}, \varvec{a}, \varvec{x}^{(i)}\bigr ) =&\ \alpha \mathcal {L}_{content}\bigl (\varvec{p}^{(i)}, \varvec{x}^{(i)} \bigr ) \ + \ \beta \mathcal {L}_{style}\bigl (\varvec{a}, \varvec{x}^{(i)}\bigr ) \nonumber \\&+ \ \gamma \mathcal {L}_{temporal}\bigl (\varvec{x}^{(i)}, \omega _{i-1}^i(\varvec{x}^{(i-1)}), \varvec{c}^{(i-1,i)}\bigr ). \end{aligned}
(8)
We optimize one frame after another, thus \varvec{x}^{(i-1)} refers to the already stylized frame i\!-\!1. Furthermore we experimented with the more robust absolute error instead of squared error for the temporal consistency loss; results are shown in Sect. 8. 

4.3 Long-term Consistency:
The short-term model has the following limitation: when some areas are occluded in some frame and disoccluded later, these areas will likely change their appearance in the stylized video. This can be counteracted by also making use of long-term motion, i.e. not only penalizing deviations from the previous frame, but also from temporally more distant frames. Let J denote the set of indices each frame should take into account, relative to the frame number. E.g. J = \{1, 2, 4\} means frame i takes frames i\!-\!1, i\!-\!2 and i\!-\!4 into account. Then, the loss function with long-term consistency is given by: \begin{aligned} \mathcal {L}_{longterm}\bigl (\varvec{p}^{(i)}, \varvec{a}, \varvec{x}^{(i)}\bigr ) =&\ \alpha \mathcal {L}_{content}\bigl (\varvec{p}^{(i)}, \varvec{x}^{(i)}\bigr ) \ + \ \beta \mathcal {L}_{style}\bigl (\varvec{a}, \varvec{x}^{(i)}\bigr ) \nonumber \\&+ \ \gamma \sum _{j\in J: i-j \ge 1} \mathcal {L}_{temporal}\bigl (\varvec{x}^{(i)}, \omega _{i-j}^i(\varvec{x}^{(i-j)}), \varvec{c}_{long}^{(i-j,i)}\bigr ) \end{aligned}
(9)
It is essential how the weights \varvec{c}_{long}^{(i-j,i)} are computed. Let \varvec{c}^{(i-j,i)} be the weights for the flow between image i\!-\!j and i, as defined for the short-term model. The long-term weights \varvec{c}_{long}^{(i-j,i)} are computed as follows: \begin{aligned} \varvec{c}_{long}^{(i-j,i)} = \max \bigl ( \varvec{c}^{(i-j,i)} - \sum _{k\in J: i-k > i-j} \varvec{c}^{(i-k,i)},\; \varvec{0} \bigr ), \end{aligned}
(10)
where \max  is taken element-wise. This means, we first apply the usual short-term constraint. For pixels in disoccluded regions we look into the past until we find a frame in which these have consistent correspondences. An advantage over simply using  \varvec{c}^{(i-j,i)} is that each pixel is connected only to the closest possible frame from the past. Since the optical flow computed over more frames is more erroneous than over fewer frames, this results in nicer videos. An empirical comparison of \varvec{c}^{(i-j,i)} and \varvec{c}_{long}^{(i-j,i)} is shown in the supplementary video (see Sect. 8.1). 

4.4 Multi-pass Algorithm:
We found that the output image tends to have less contrast and is less diverse near image boundaries than in other areas of the image. For mostly static videos this effect is hardly visible. However, in cases of strong camera motion the areas from image boundaries move towards the center of the image, which leads to a lower image quality over time when combined with our temporal constraint. Therefore, we developed a multi-pass algorithm which processes the whole sequence in multiple passes and alternating directions. The basic idea is that we progressively propagate intermediate results in both forward and backward direction, avoiding an one-way information flow from the image boundaries to the center only. Every pass consists of a relatively low number of iterations without full convergence. At the beginning, we process every frame independently based on a random initialization. After that, we blend frames with non-disoccluded parts of previous frames warped according to the optical flow, then run the optimization algorithm for some iterations initialized with this blend. The direction in which the sequence is processed is alternated in every pass. We repeat this blending and optimization to convergence. Formally, let \varvec{x}'^{(i)(j)} be the initialization of frame i in pass j and \varvec{x}^{(i)(j)} the corresponding output after some iterations of the optimization algorithm. When processed in forward direction, the initialization of frame i is created as follows: \begin{aligned} \varvec{x'}^{(i)(j)} = {\left\{ \begin{array}{ll} \varvec{x}^{(i)(j-1)} &{}\text {if } i=1,\\ \delta \varvec{c}^{(i-1,i)} \circ \omega _{i-1}^{i}\bigl (\varvec{x}^{(i-1)(j)}\bigr ) + (\overline{\delta } \varvec{1} + \delta \overline{\varvec{c}}^{(i-1,i)}) \circ \varvec{x}^{(i)(j-1)} &{}\text {else}. \end{array}\right. } \end{aligned}
(11)
Here \circ  denotes element-wise vector multiplication, \delta  and \overline{\delta } = 1\!-\!\delta  are the blend factors, \varvec{1} is a vector of all ones, and \overline{\varvec{c}} = \varvec{1} - \varvec{c}. Analogously, the initialization for a backward direction pass is: \begin{aligned} \varvec{x'}^{(i)(j)} = {\left\{ \begin{array}{ll} \varvec{x}^{(i)(j-1)} &{}\text {if } i=N_{\text {frames}}\\ \delta \varvec{c}^{(i+1,i)} \circ \omega _{i+1}^{i}\bigl (\varvec{x}^{(i+1)(j)}\bigr ) + (\overline{\delta } \varvec{1} + \delta \overline{\varvec{c}}^{(i+1,i)}) \circ \varvec{x}^{(i)(j-1)} &{}\text {else} \end{array}\right. } \end{aligned}
(12)
The multi-pass algorithm can be combined with the temporal consistency loss described above. We achieved good results when we disabled the temporal consistency loss in several initial passes and enabled it in later passes only after the images had stabilized. 

5 Experiments:
In this section, we briefly describe implementation details and present experimental results produced with different versions of our algorithm. While we did our best to make the paper self-contained, it is not possible to demonstrate effects like video flickering in still images. We therefore advise the readers to watch the supplementary video, which is available at https://youtu.be/vQk_Sfl7kSc. 

5.1 Implementation Details:
Our implementationFootnote 1 is based on the Torch [2] implementation called neural-style
Footnote 2. We used the following layers of the VGG-19 network [10] for computing the losses: relu4_2 for the content and relu1_1,relu2_1,relu3_1,relu4_1,relu5_1 for the style. The energy function was minimized using L-BFGS. For precise evaluation we incorporated the following strict stopping criterion: the optimization was considered converged if the loss did not change by more than 0.01\,\% during 50 iterations. This typically resulted in roughly 2000 to 3000 iterations for the first frame and roughly 400 to 800 iterations for subsequent frames when optimizing with our temporal constraint, depending on the amount of motion and the complexity of the style image. Using a convergence threshold of 0.1\,\% cuts the number of iterations and the running time in half, and we found it still produces reasonable results in most cases. However, we used the stronger criterion in our experiments for the sake of accuracy. For videos of resolution 350 \times 450 we used weights \alpha = 1 and \beta = 20 for the content and style losses, respectively (default values from neural-style), and weight \gamma = 200 for the temporal losses. However, the weights should be adjusted if the video resolution is different. We provide the details in Sect. 7.2. For our multi-pass algorithm, we used 100 iterations per pass and set \delta = 0.5, but we needed at least 10 passes for good results, so this algorithm needs more computation time than our previous approaches. We used DeepMatching, DeepFlow and EpicFlow implementations provided by the authors of these methods. We used the “improved-settings” flag in DeepMatching 1.0.1 and the default settings for DeepFlow 1.0.1 and EpicFlow 1.00. 
Runtime. For the relaxed convergence threshold of 0.1\,\% with random initialization the optimization process needed on average roughly eight to ten minutes per frame at a resolution of 1024 \times 436 on an Nvidia Titan X GPU. When initialized with the warped previous frame and combined with our temporal loss, the optimization converges 2 to 3 times faster, three minutes on average. Optical flow computation runs on a CPU and takes roughly 3 minutes per frame pair (forward and backward flow together), therefore it can be performed in parallel with the style transfer. Hence, our modified algorithm is roughly 3 times faster than naive per-frame processing, while providing temporally consistent output videos. 

5.2 Short-term Consistency:
We evaluated our short-term temporal loss on 5 diverse scenes from the MPI Sintel Dataset [1], with 20 to 50 frames of resolution 1024 \times 436 pixels per scene, and 6 famous paintings (shown in Sect. 7.1) as style images. The Sintel dataset provides ground truth optical flow and ground truth occlusion areas, which allows a quantitative study. We warped each stylized frame i back with the ground truth flow and computed the difference with the stylized frame i-1 in non-disoccluded regions. We use the mean square of this difference (that is, the mean squared error) as a quantitative performance measure. On this benchmark we compared several approaches: our short-term consistency loss with DeepFlow and EpicFlow, as well as three different initializations without the temporal loss: random noise, the previous stylized frame and the previous stylized frame warped with DeepFlow. We set \alpha = 1, \beta = 100, \gamma = 400. A qualitative comparison is shown in Fig. 2. Quantitative results are in Table 1. The most straightforward approach, processing every frame independently, performed roughly an order of magnitude worse than our more sophisticated methods. In most cases, the temporal penalty significantly improved the results. The ambush scenes are exceptions, since they contain very large motion and the erroneous optical flow impairs the temporal constraint. Interestingly, on average DeepFlow performed slightly better than EpicFlow in our experiments, even through EpicFlow outperforms DeepFlow on the Sintel optical flow benchmark. Fig. 2.Close-up of a scene from Sintel, combined with The Scream painting. (a) With temporal constraint (b) Initialized with previous image warped, but without the constraint (c) Initialized randomly. The marked regions show most visible differences. Error images show the contrast-enhanced absolute difference between frame #1 and frame #2 warped back using ground truth optical flow, as used in our evaluation. The effect of the temporal constraint is very clear in the error images and in the corresponding video. 
Table 1. Short-term consistency benchmark results. Mean squared error of different methods on 5 video sequences, averaged over 6 styles, is shown. Pixel values in images were between 0 and 1.


5.3 Long-Term Consistency and Multi-pass Algorithm:
The short-term consistency benchmark presented above cannot evaluate the long-term consistency of videos (since we do not have long-term ground truth flow available) and their visual quality (this can only be judged by humans). We therefore excluded the long-term penalty and the multi-pass approach from the quantitative comparison and present only qualitative results. Please see the supplementary video for more results. Figure 3 shows a scene from Miss Marple where a person walks through the scene. Without our long-term consistency model, the background looks very different after the person passes by. The long-term consistency model keeps the background unchanged. Figure 4 shows another scene from Miss Marple with fast camera motion. The multi-pass algorithm avoids the artifacts introduced by the basic algorithm. Fig. 3.Scene from Miss Marple, combined with The Starry Night painting. (a) Short-term consistency only. (b) Long-term consistency with J = \{1, 10, 20, 40\}. Corresponding video is linked in Sect. 8.1. 
Fig. 4.The multi-pass algorithm applied to a scene from Miss Marple. With the default method, the image becomes notably brighter and loses contrast, while the multi-pass algorithm yields a more consistent image quality over time. Corresponding video is linked in Sect. 8.1. 


6 Conclusion:
We presented a set of techniques for style transfer in videos: suitable initialization, a loss function that enforces short-term temporal consistency of the stylized video, a loss function for long-term consistency, and a multi-pass approach. As a consequence, we can produce stable and visually appealing stylized videos even in the presence of fast motion and strong occlusion.