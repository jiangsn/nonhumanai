SECTION 1. Introduction: Deep convolutional neural networks (ConvNets) currently set the state-of-the-art in inverse image reconstruction problems such as denoising [5], [20] or single-image super-resolution [19], [29], [18]. ConvNets have also been used with great success in more “exotic” problems such as reconstructing an image from its activations within certain deep networks or from its HOG descriptor [8]. More generally, ConvNets with similar architectures are nowadays used to generate images using such approaches as generative adversarial networks [11], variational autoencoders [16], and direct pixelwise error minimization [9], [3]. State-of-the-art ConvNets for image restoration and generation are almost invariably trained on large datasets of images. One may thus assume that their excellent performance is due to their ability to learn realistic image priors from data. However, learning alone is insufficient to explain the good performance of deep networks. For instance, the authors of [33] recently showed that the same image classification network that generalizes well when trained on genuine data can also overfit when presented with random labels. Thus, generalization requires the structure of the network to “resonate” with the structure of the data. However, the nature of this interaction remains unclear, particularly in the context of image generation.
Figure 1: Super-resolution using the deep image prior. Our method uses a randomly-initialized ConvNet to upsample an image, using its structure as an image prior; similar to bicubic upsampling, this method does not require learning, but produces much cleaner results with sharper edges. In fact, our results are quite close to state-of-the-art super-resolution methods that use ConvNets learned from large datasets. The deep image prior works well for all inverse problems we could test. 
In this work, we show that, contrary to the belief that learning is necessary for building good image priors, a great deal of image statistics are captured by the structure of a convolutional image generator independent of learning. This is particularly true for the statistics required to solve various image restoration problems, where the image prior is required to integrate information lost in the degradation processes. To show this, we apply untrained ConvNets to the solution of several such problems. Instead of following the common paradigm of training a ConvNet on a large dataset of example images, we fit a generator network to a single degraded image. In this scheme, the network weights serve as a parametrization of the restored image. The weights are randomly initialized and fitted to maximize their likelihood given a specific degraded image and a task-dependent observation model. Stated in a different way, we cast reconstruction as a conditional image generation problem and show that the only information required to solve it is contained in the single degraded input image and the handcrafted structure of the network used for reconstruction. We show that this very simple formulation is very competitive for standard image processing problems such as denoising, inpainting and super-resolution. This is particularly remarkable because no aspect of the network is learned from data; instead, the weights of the network are always randomly initialized, so that the only prior information is in the structure of the network itself. To the best of our knowledge, this is the first study that directly investigates the prior captured by deep convolutional generative networks independently of learning the network parameters from images. In addition to standard image restoration tasks, we show an application of our technique to understanding the information contained within the activations of deep neural networks. For this, we consider the “natural pre-image” technique of [21], whose goal is to characterize the invariants learned by a deep network by inverting it on the set of natural images. We show that an untrained deep convolutional generator can be used to replace the surrogate natural prior used in [21] (the TV norm) with dramatically improved results. Since the new regularizer, like the TV norm, is not learned from data but is entirely handcrafted, the resulting visualizations avoid potential biases arising form the use of powerful learned regularizers [8]. 

SECTION 2. Method: Deep networks are applied to image generation by learning generator/decoder networks x=fθ(z) that map a random code vector z to an image x. This approach can be used to sample realistic images from a random distribution [11]. Here we focus on the case where the distribution is conditioned on a corrupted observation x0 to solve inverse problems such as denoising [5] and super-resolution [7].
Figure 2: Learning curves for the reconstruction task using: A natural image, the same plus i.i.d. Noise, the same randomly scrambled, and white noise. Naturally-looking images result in much faster convergence, whereas noise is rejected. 
Our aim is to investigate the prior implicitly captured by the choice of a particular generator network structure, before any of its parameters are learned. We do so by interpreting the neural network as a parametrization x=fθ(z) of an image x∈R3×H×W. Here z∈RC′×H′×W′ is a code tensor/vector and θ are the network parameters. The network itself alternates filtering operations such as convolution, upsampling and non-linear activation. In particular, most of our experiments are performed using a U-Net type “hourglass” architecture with skip-connections, where z and x have the same spatial size. Our default architecture has two million parameters θ (see Supplementary Material for the details of all used architectures). To demonstrate the power of this parametrization, we consider inverse tasks such as denoising, super-resolution and inpainting. These can be expressed as energy minimization problems of the type x∗=minxE(x;x0)+R(x),(1)View Source\begin{equation*}
x^{\ast}= \min\limits_{x}E(x;x_{0})+R(x),\tag{1}
\end{equation*} where E(x;x0) is a task-dependent data term, x0 the noisy/low-resolution/occluded image, and R(x) a regularizer. The choice of data term E(x;x0) is dictated by the application and will be discussed later. The choice of regularizer, which usually captures a generic prior on natural images, is more difficult and is the subject of much research. As a simple example, R(x) can be the Total Variation (TV) of the image, which encourages solutions to contain uniform regions. In this work, we replace the regularizer R(x) with the implicit prior captured by the neural network, as follows: θ∗=argminθ E(fθ(z);x0),x∗=fθ∗(z).(2)View Source\begin{equation*}
\theta^{\ast}=\underset{\theta}{\arg\!\min}\ E(f_{\theta}(z); x_{0}),\qquad x^{\ast}=f_{\theta^{\ast}}(z). \tag{2}\end{equation*} The minimizer θ is obtained using an optimizer such as gradient descent starting from a random initialization of the parameters. Given a (local) minimizer θ∗, the result of the restoration process is obtained as x∗=fθ∗(z). Note that while it is also possible to optimize over the code z, in our experiments we do not do that. Thus, unless noted otherwise, z is a fixed 3D tensor with 32 feature maps and of the same spatial size as x filled with uniform noise. We found that additionally perturbing z randomly at every iteration lead to better results in some experiments (c.f. Supplementary material). In terms of (1), the prior R(x) defined by (2) is an indicator function R(x)=0 for all images that can be produced from z by a deep ConvNet of a certain architecture, and R(x)=+∞ for all other signals. Since no aspect of the network is pre-trained from data, such deep image prior is effectively handcrafted, just like the TV norm. We show that this hand-crafted prior works very well for various image restoration tasks. A Parametrization with High Noise Impedance: One may wonder why a high-capacity network fθ can be used as a prior at all. In fact, one may expect to be able to find parameters θ recovering any possible image x, including random noise, so that the network should not impose any restriction on the generated image. We now show that, while indeed almost any image can be fitted, the choice of network architecture has a major effect on how the solution space is searched by methods such as gradient descent. In particular, we show that the network resists “bad” solutions and descends much more quickly towards naturally-looking images. The result is that minimizing (2) either results in a good-looking local optimum, or, at least, the optimization trajectory passes near one. In order to study this effect quantitatively, we consider the most basic reconstruction problem: given a target image x0, we want to find the value of the parameters θ∗ that reproduce that image. This can be setup as the optimization of (2) using a data term comparing the generated image to x0:
E(x;x0)=∥x−x0∥2(3)View Source\begin{equation*}
E(x;x_{0})=\Vert x-x_{0}\Vert^{2}\tag{3}
\end{equation*} Plugging this in eq. (2) leads us to the optimization problem minθ∥fθ(z)−x0∥2(4)View Source\begin{equation*}
\min\limits_{\theta}\Vert f_{\theta}(z)-x_{0}\Vert^{2} \tag{4}
\end{equation*} Figure 2 shows the value of the energy E(x;x0) as a function of the gradient descent iterations for four different choices for the image x0: 1) a natural image, 2) the same image plus additive noise, 3) the same image after randomly permuting the pixels, and 4) white noise. It is apparent from the figure that optimization is much faster for cases 1) and 2), whereas the parametrization presents significant “inertia” for cases 3) and 4). Thus, although in the limit the parametrization can fit unstructured noise, it does so very reluctantly. In other words, the parametrization offers high impedance to noise and low impedance to signal. Therefore for most applications, we restrict the number of iterations in the optimization process (2) to a certain number of iterations. The resulting prior then corresponds to projection onto a reduced set of images that can be produced from z by ConvNets with parameters θ that are not too far from the random initialization θ0. 

SECTION 3. Applications: We now show experimentally how the proposed prior works for diverse image reconstruction problems. Due to space limitations, we present a few examples and numbers and include many more in the Supplementary material and the project webpage [30]. Denoising and Generic Reconstruction: As our parametrization presents high impedance to image noise, it can be naturally used to filter out noise from an image. The aim of denoising is to recover a clean image x from a noisy observation x0. Sometimes the degradation model is known: x0=x+ϵ where ϵ follows a particular distribution. However, more often in blind denoising the noise model is unknown. Here we work under the blindness assumption, but the method can be easily modified to incorporate information about noise model. We use the same exact formulation as eqs. (3) and (4) and, given a noisy image x0, recover a clean image x∗=fθ∗(z) after substituting the minimizer θ∗ of eq. (4). Our approach does not require a model for the image degradation process that it needs to revert. This allows it to be applied in a “plug-and-play” fashion to image restoration tasks, where the degradation process is complex and/or unknown and where obtaining realistic data for supervised training is difficult. We demonstrate this capability by several qualitative examples in fig. 4 and in the supplementary material, where our approach uses the quadratic energy (3) leading to formulation (4) to restore images degraded by complex and unknown compression artifacts. Figure 3 (top row) also demonstrates the applicability of the method beyond natural images (a cartoon in this case). We evaluate our denoising approach on the standard dataset1, consisting of 9 colored images with noise strength of \sigma=25. We achieve a PSNR of 29.22 after 1800 optimization steps. The score is improved up to 30.43 if we additionally average the restored images obtained in the last iterations (using exponential sliding window). If averaged over two optimization runs our method further improves up to 31.00 PSNR. For reference, the scores for the two popular approaches CMB3D [6] and Non-local means [4] that do not require pretraining are 31.42 and 30.26 respectively.
Figure 3: Blind restoration of a JPEG-compressed image. (electronic zoom-in recommended) Our approach can restore an image with a complex degradation (JPEG compression in this case). As the optimization process progresses, the deep image prior allows to recover most of the signal while getting rid of halos and blockiness (after 2400 iterations) before eventually overfitting to the input (at 50K iterations). 
Figure 4: Blind image denoising. The deep image prior is successful at recovering both man-made and natural patterns. For reference, the result of a state-of-the-art non-learned denoising approach [6] is shown. 
Super-Resolution: The goal of super-resolution is to take a low resolution (LR) image x_{0}\in \mathbb{R}^{3\times H\times W} and upsampling factor t, and generate a corresponding high resolution (HR) version x\in \mathbb{R}^{3\times tH\times tW}. To solve this inverse problem, the data term in (2) is set to: \begin{equation*}E(x;x_{0})=\Vert d(x)-x_{0}\Vert^{2}\tag{5}\end{equation*}View Source\begin{equation*}E(x;x_{0})=\Vert d(x)-x_{0}\Vert^{2}\tag{5}\end{equation*} where d(\cdot):\mathbb{R}^{3\times tH\times tW}\rightarrow \mathbb{R}^{3\times H\times W} is a downsampling operator that resizes an image by a factor t. Hence, the problem is to find the HR image x that, when downsampled, is the same as the LR image x_{0}. Super-resolution is an ill-posed problem because there are infinitely many HR images x that reduce to the same LR image x_{0} (i.e. the operator d is far from surjective). Regularization is required in order to select, among the infinite minimizers of (5), the most plausible ones. Following eq. (2), we regularize the problem by considering the reparametrization x=f_{\theta}(z) and optimizing the resulting energy w.r.t. \theta. Optimization still uses gradient descent, exploiting the fact that both the neural network and the most common downsampling operators, such as Lanc-zos, are differentiable. We evaluate super-resolution ability of our approach using Set5 [2] and Set14 [32] datasets. We use a scaling factor of 4 to compare to other works, and show results with scaling factor of 8 in supplementary materials. We fix the number of optimization steps to be 2000 for every image. Qualitative comparison with bicubic upsampling and state-of-the art learning-based methods SRResNet [19], LapSRN [29] is presented in fig. 5. Our method can be fairly compared to bicubic, as both methods never use other data than a given low-resolution image. Visually, we approach the quality of learning-based methods that use the MSE loss. GAN-based [11] methods SRGAN [19] and EnhanceNet [28] (not shown in the comparison) intelligently hallucinate fine details of the image, which is impossible with our method that uses absolutely no information about the world of HR images. We compute PSNRs using center crops of the generated images. Our method achieves 29.90 and 27.00 PSNR on Set5 and Set14 datasets respectively. Bicubic upsampling gets a lower score of 28.43 and 26.05, while SRResNet has PSNR of 32.10 and 28.53. While our method is still outperformed by learning-based approaches, it does considerably better than bicubic upsampling. Visually, it seems to close most of the gap between bicubic and state-of-the-art trained ConvNets (c.f. fig. 1, fig. 5 and suppmat). Inpainting: In image inpainting, one is given an image x_{0} with missing pixels in correspondence of a binary mask m\in\{0,1\}^{H\times W}; the goal is to reconstruct the missing data. The corresponding data term is given by \begin{equation*}
E(x;x_{0})=\Vert(x-x_{0})\odot m\Vert^{2}, \tag{6}
\end{equation*}View Source\begin{equation*}
E(x;x_{0})=\Vert(x-x_{0})\odot m\Vert^{2}, \tag{6}
\end{equation*} where ⊙ is Hadamard's product. The necessity of a data prior is obvious as this energy is independent of the values of the missing pixels, which would therefore never change after initialization if the objective was optimized directly over pixel values x. As before, the prior is introduced by optimizing the data term w.r.t. the reparametrization (2). In the first example (fig. 7, top row) inpainting is used to remove text overlaid on an image. Our approach is compared to the method of [27] specifically designed for inpainting. Our approach leads to an almost perfect results with virtually no artifacts, while for [27] the text mask remains visible in some regions. Next, fig. 7 (bottom) considers inpainting with masks randomly sampled according to a binary Bernoulli distribution. First, a mask is sampled to drop 50% of pixels at random. We compare our approach to a method of [25] based on convolutional sparse coding. To obtain results for [25] we first decompose the corrupted image x_{0} into low and high frequency components similarly to [12] and run their method on the high frequency part. For a fair comparison we use the version of their method, where a dictionary is built using the input image (shown to perform better in [25]). The quantitative comparison on the standard data set [14] for our method is given in table 1, showing a strong quantitative advantage of the proposed approach compared to convolutional sparse coding. In fig. 7 (bottom) we present a representative qualitative visual comparison with [25].
Figure 5: 4x image super-resolution. Similarly to e.g. Bicubic upsampling, our method never has access to any data other than a single low-resolution image, and yet it produces much cleaner results with sharp edges close to state-of-the-art super-resolution methods (LapSRN [18], SRResNet [19]) which utilize networks trained from large datasets. 
Figure 6: Region inpainting. In many cases, deep image prior is sufficient to successfully inpaint large regions. Despite using no learning, the results may be comparable to [15] which does. The choice of hyper-parameters is important (for example (d) demonstrates sensitivity to the learning rate), but a good setting works well for most images we tried. 
We also apply our method to inpainting of large holes. Being non-trainable, our method is not expected to work correctly for “highly-semantical” large-hole inpainting (e.g. face inpainting). Yet, it works surprisingly well for other situations. We compare to a learning-based method of [15] in fig. 6. The deep image prior utilizes context of the image and interpolates the unknown region with textures from the known part. Such behaviour highlights the relation between the deep image prior and traditional self-similarity priors. In fig. 8, we compare deep priors corresponding to several architectures. Our findings here (and in other similar comparisons) seem to suggest that having deeper architecture is beneficial, and that having skip-connections that work so well for recognition tasks (such as semantic segmentation) is highly detrimental.
Figure 7: Comparison with two recent inpainting approaches. Top – comparison with shepard networks [27] on text inpainting example. Bottom – comparison with convolutional sparse coding [25] on inpainting 50% of missing pixels. In both cases, our approach performs better on the images used in the respective papers. 
Table 1: Comparison between our method and the algorithm in [25]. See fig. 7 bottom row for visual comparison.
Natural Pre-Image: The natural pre-image method of [21] is a diagnostic tool to study the invariances of a lossy function, such as a deep network, that operates on natural images. Let \Phi be the first several layers of a neural network trained to perform, say, image classification. The pre-image is the set \Phi^{-1}(\Phi(x_{0}))=\{x\in \mathcal{X}:\Phi(x)=\Phi(x_{0})\} of images that result in the same representation \Phi(x_{0}). Looking at this set reveals which information is lost by the network, and which invariances are gained. Finding pre-image points can be formulated as minimizing the data term E(x;x_{0})=\Vert\Phi(x)-\Phi(x_{0})\Vert^{2}. However, optimizing this function directly may find “arrifacts”, i.e. non-natural images for which the behavior of the network \Phi is in principle unspecified and that can thus drive it arbitrarily. More meaningful visualization can be obtained by restricting the pre-image to a set \mathcal{X} of natural images, called a natural pre-image in [21]. In practice, finding points in the natural pre-image can be done by regularizing the data term similarly to the other inverse problems seen above. The authors of [21] prefer to use the TV norm, which is a weak natural image prior, but is relatively unbiased. On the contrary, papers such as [8] learn to invert a neural network from examples, resulting in better looking reconstructions, which however may be biased towards learning data-driven inversion prior. Here, we propose to use the deep image prior (2) instead. As this is handcrafted like the TV-norm, it is not biased towards a particular training set. On the other hand, it results in inversions at least as interpretable as the ones of [8]. For evaluation, our method is compared to the ones of [22] and [8]. Figure 9 shows the results of inverting representations \Phi obtained by considering progressively deeper subsets of AlexNet [17]: conv1, conv2, …, conv5, fc6, fc7, and fc8. Pre-images are found either by optimizing (2) using a structured prior.
Figure 8: Inpainting using different depths and architectures. The figure shows that much better inpainting results can be obtained by using deeper random networks. However, adding skip connections to ResNet in U-Net is highly detrimental. 
Figure 9: AlexNet inversion. Given the image on the left, we show the natural pre-image obtained by inverting different layers of AlexNet (trained for classification on ImageNet ISLVRC) using three different regularizers: The deep image prior, the TV norm prior of [21], and the network trained to invert representations on a hold-out set [8]. The reconstructions obtained with the deep image prior are in many ways at least as natural as [8], yet they are not biased by the learning process. 
As seen in fig. 9, our method results in dramatically improved image clarity compared to the simple TV-norm. The difference is particularly remarkable for deeper layers such as fc6 and fc7, where the TV norm still produces noisy images, whereas the structured regularizer produces images that are often still interpretable. Our approach also produces more informative inversions than a learned prior of [8], which have a clear tendency to regress to the mean. Flash-No Flash Reconstruction: While in this work we focus on single image restoration, the proposed approach can be extended to the tasks of the restoration of multiple images, e.g. for the task of video restoration. We therefore conclude the set of application examples with a qualitative example demonstrating how the method can be applied to perform restoration based on pairs of images. In particular, we consider flash-no flash image pair-based restoration [26], where the goal is to obtain an image of a scene with the lighting similar to a no-flash image, while using the flash image as a guide to reduce the noise level.
Figure 10: Reconstruction based on flash and no-flash image pair. The deep image prior allows to obtain low-noise reconstruction with the lighting very close to the no-flash image. It is more successful at avoiding “leaks” of the lighting patterns from the flash pair than joint bilateral filtering [26] (c.f. Blue inset). 
In general, extending the method to more than one image is likely to involve some coordinated optimization over the input codes z that for single-image tasks in our approach was most often kept fixed and random. In the case of flash-no-flash restoration, we found that good restorations were obtained by using the denoising formulation (4), while using flash image as an input (in place of the random vector z). The resulting approach can be seen as a non-linear generalization of guided image filtering [13]. The results of the restoration are given in the fig. 10. 

SECTION 4. Related Work: Our method is obviously related to image restoration and synthesis methods based on learnable ConvNets and referenced above. At the same time, it is as much related to an alternative group of restoration methods that avoid training on the hold-out set. This group includes methods based on joint modeling of groups of similar patches inside corrupted image [4], [6], [10], which are particularly useful when the corruption process is complex and highly variable (e.g. spatially-varying blur [1]). Also in this group are methods based on fitting dictionaries to the patches of the corrupted image [23], [32] as well as methods based on convolutional sparse coding [31], which can also fit statistical models similar to shallow ConvNets to the reconstructed image [25]. The work [20] investigates the model that combines ConvNet with a self-similarity based denoising and thus also bridges the two groups of methods, but still requires training on a hold-out set. Overall, the prior imposed by deep ConvNets and investigated in this work seems to be highly related to self-similarity-based and dictionary-based priors. Indeed, as the weights of the convolutional filters are shared across the entire spatial extent of the image this ensures a degree of self-similarity of individual patches that a generative ConvNet can potentially produce. The connections between ConvNets and convolutional sparse coding run even deeper and are investigated in [24] in the context of recognition networks, and more recently in [25], where a single-layer convolutional sparse coding is proposed for reconstruction tasks. The comparison of our approach with [25] (fig. 7 and table 1) however suggests that using deep ConvNet architectures popular in modern deep learning-based approaches may lead to more accurate restoration results at least in some circumstances. 

SECTION 5. Discussion: We have investigated the success of recent image generator neural networks, teasing apart the contribution of the prior imposed by the choice of architecture from the contribution of the information transferred from external images through learning. As a byproduct, we have shown that fitting a randomly-initialized ConvNet to corrupted images works as a “Swiss knife” for restoration problems. While practically slow (taking several minutes of GPU computation per image), this approach does not require modeling of the degradation process or pre-training. Our results go against the common narrative that explain the success of deep learning in image restoration to the ability to learn rather than hand-craft priors; instead, random networks are better hand-crafted priors, and learning builds on this basis. This also validates the importance of developing new deep learning architectures. 
ACKNOWLEDGEMENTS: DU and VL are supported by the Ministry of Education and Science of the Russian Federation (grant 14.756.31.0001) and AV is supported by ERC 677195-IDIU.