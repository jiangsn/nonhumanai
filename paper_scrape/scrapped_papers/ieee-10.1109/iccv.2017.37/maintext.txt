SECTION 1. Introduction: Traditional video frame interpolation methods estimate optical flow between input frames and synthesizing intermediate frames guided by optical flow [3]. However, their performance largely depends on the quality of optical flow, which is challenging to estimate accurately in regions with occlusion, blur, and abrupt brightness change. Based on the observation that the ultimate goal of frame interpolation is to produce high-quality video frames and optical flow estimation is only an intermediate step, recent methods formulate frame interpolation [36] or extrapolation [14], [21], [58] as a convolution process. Specifically, they estimate spatially-adaptive convolution kernels for each output pixel and convolve the kernels with the input frames to generate a new frame. The convolution kernels jointly account for the two separate steps of motion estimation and re-sampling involved in traditional frame interpolation methods. In order to handle large motion, large kernels are required. For example, Niklaus et al. employ a neural network to output two 41×41 kernels for each output pixel [36]. To generate the kernels for all pixels in a 1080p video frame, the output kernels alone will require 26 GB of memory. The memory demand increases quadratically with the kernel size and thus limits the maximal motion to be handled. Given this limitation, Niklaus et al. trained a neural network to output the kernels pixel by pixel.
Figure 1: Video frame interpolation. Compared to the recent convolution approach that utilizes 2D kernels [36] (b), our separable convolution methods, especially the one with perceptual loss (d), incorporate 1D kernels that allow for full-frame interpolation and produce higher-quality results. 
This paper presents a spatially-adaptive separable convolution approach for video frame interpolation. Our work is inspired by the success of using separable filters to approximate full 2D filters for other computer vision tasks, like image structure extraction [41]. For frame synthesis, two 2D convolution kernels are required to generate an output pixel. Our approach approximates each of these with a pair of 1D kernels, one horizontal and one vertical. In this way, an n×n convolution kernel can be encoded using only 2n variables. This allows our method to employ a fully convolutional neural network that takes two video frames as input and produces the separable kernels for all output pixels at once. For a 1080p video frame, using separable kernels that approximate 41×41 ones only requires 1.27 GB instead of 26 GB of memory. Since our method is able to generate the full-frame output, we can incorporate perceptual loss functions [11], [22], [27], [42], [65] to further improve the visual quality of the interpolation results, as shown in Figure 1. Our deep neural network is fully convolutional and can be trained end-to-end using widely available video data without any difficult-to-obtain meta data like optical flow. Our experiments show that our method is able to compare favorably to representative state-of-the-art interpolation methods both qualitatively and quantitatively on representative challenging scenarios and provides a practical solution to high-quality video frame interpolation. 

SECTION 2. Related Work: Video frame interpolation is a classic topic in computer vision and video processing. Common frame interpolation approaches estimate dense motion, typically optical flow, between two input frames and then interpolate one or more intermediate frames guided by the motion [3], [53], [60]. The performance of these methods often depends on optical flow and special care, such as flow interpolation, is necessary to handle problems with optical flow [3]. Generic image-based rendering algorithms can also be used to improve frame synthesis results [33], [66]. Different from optical flow based methods, Meyer et al. developed a phase-based interpolation method that represents motion in the phase shift of individual pixels and generates intermediate frames by per-pixel phase modification [35]. This phase-based method often produces impressive interpolation results; however, it sometimes cannot preserve high-frequency details in videos with large temporal changes. Our research is inspired by the success of applying deep learning to optical flow estimation [2], [12], [16], [19], [50]–​[52], artistic style transfer [17], [22], [28], and image enhancement [6], [9], [10], [46], [47], [55], [57], [62], [65]. Our work belongs to the category of research that employs deep neural networks for view synthesis. Some of these methods render unseen views from input images for objects like faces and chairs, instead of complex real-world scenes [13], [26], [49], [59]. Flynn et al. developed a method that generates a novel image by projecting input images onto multiple depth planes and combining these depth planes to create the novel view [15]. Kalantari et al. proposed a view expansion method for light field imaging that uses two sequential convolutional neural networks to model the disparity and color estimation steps of view interpolation and trained these two networks simultaneously [23]. Xie et al. developed a neural network that synthesizes an extra view from a monocular video to convert it to a stereo video [54]. Recently, Zhou et al. developed an method that employs a convolutional neural network to estimate appearance flow and then uses this estimation to warp input pixels to create a novel view [64]. Their method can warp individual input frames and blend them together to produce a frame between the input ones. The deep voxel flow approach, a concurrent work to our paper, developed a deep neural network to output dense voxel flows optimized frame interpolation results [29]. Long et al. also developed a convolutional neural network to interpolate a frame in between two input ones; however, their method generates the interpolated frame as an intermediate step to estimate optical flow [30]. Our method is most relevant to the recent frame interpolation [36] or extrapolation [14], [21], [58] methods that combine motion estimation and frame synthesis into a single convolution step. These methods estimate spatially-varying kernels for each output pixel and convolve them with input frames to generate a new frame. Since these convolution methods require large kernels to handle large motion, they cannot synthesize all the pixels for a high-resolution video simultaneously, limited by the available memory. For example, the method from Niklaus et al. interpolates frames pixel by pixel. Although they employed a shift-and-stitch strategy to generate multiple pixels in each pass, the number of pixels that can be synthesized simultaneously is still limited [36]. Other methods only generate a relatively low-resolution image. Our work extends these algorithms by estimating separable 1D kernels to approximate 2D kernels which significantly reduces the required amount of memory. Consequently, our method can interpolate a 1080p frame in one pass. Moreover, our method also supports the incorporation of perceptual loss functions, which need to be constrained on a continuous image region, to improve the visual quality of the interpolated frames. 

SECTION 3. Video Frame Interpolation: To make this paper self-complete, we first briefly describe the recent adaptive convolution approach to video frame interpolation [36] and define notations. We then describe how we develop our separable convolution-based frame interpolation method. Our goal is to interpolate a frame I^ temporally in the middle of the two input video frames I1 and I2. For each output pixel I^(x,y), the convolution-based interpolation method estimates a pair of 2D convolution kernels K1(x,y) and K2(x,y) and uses them to convolve with I1 and I2 to compute the color of the output pixel as follows. I^(x,y)=K1(x,y)∗P1(x,y)+K2(x,y)∗P2(x,y)(1)View Source\begin{equation*}
\hat{I}(x, y)=K_{1}(x, y)\ast P_{1}(x, y)+K_{2}(x, y)\ast P_{2}(x, y) \tag{1}
\end{equation*} where P1(x,y) and P2(x,y) are the patches centered at (x,y) in I1 and I2. The pixel-dependent kernels K1 and K2 capture both motion and re-sampling information required for interpolation. To capture large motion, large-size kernels are required. Niklaus et al. used 41×41 kernels [36] and it is difficult to estimate them at once for all the pixels of a high-resolution frame simultaneously, due to the large amount of parameters and the limited memory. Their method thus estimates each individual pair of kernels pixel by pixel using a deep convolutional neural network.
Figure 2: An overview of our neural network architecture. Given input frames I1 and I2, an encoder-decoder network extracts features that are given to four sub-networks that each estimate one of the four 1D kernels for each output pixel in a dense pixel-wise manner. The estimated pixel-dependent kernels are then convolved with the input frames to produce the interpolated frame I^. Note that ∗ denotes a local convolution. 
Our method addresses this problem by estimating a pair of 1D kernels that approximate a 2D kernel. That is, we estimate ⟨k1,v,k1,h⟩ and ⟨k2,v, k2,h⟩ to approximate K1 as k1,v∗k1,h and K2 as k2,v∗k2,h. Thus, our method reduces the number of kernel parameters from n2 to 2n for each kernel. This enables the synthesis of a high-resolution video frame in one pass and the incorporation of perceptual loss to further improve the visual quality of the interpolation results, as detailed in the following subsections. 3.1. Separable Kernel Estimation: We design a fully convolutional neural network that given input frames I1 and I2, estimates two pairs of 1D kernels ⟨k1,v,k1,h⟩ and ⟨k2,v, k2,h⟩ for each pixel in the output frame I^, as illustrated in Figure 2. We treat each color channel equally and apply the same 1D kernels to each of the RGB channels to synthesize the output pixel. Note that applying the estimated kernels to the input images is a local convolution and we implement it as a network layer of our neural network similar to a position-varying dynamics convolution layer in recent work [14], [21], [58]; therefore our neural network is end-to-end trainable.
Figure 3: Checkerboard artifacts. 
Our neural network consists of a contracting component to extract features and an expanding part that incorporates upsampling layers to perform the dense prediction. We furthermore use skip connections [5], [31] to let the expanding layers incorporate features from the contracting part of the neural network, as shown in Figure 2. To estimate four sets of 1D kernels, we direct the information flow in the last expansion layer into four sub-networks, with each subnetwork estimating one of the kernels. We could have modeled this jointly with a combined representation of the four kernels as well; however, we noticed a faster convergence during training when using four sub-networks. We found stacks of 3×3 convolution layers together with Rectified Linear Units to be effective. Like Zhao et al. [63], we noticed that the average pooling performs well in the context of pixel-wise predictions and used it in our network accordingly. The upsampling layers in the expanding part can be implemented in various ways, such as transposed convolution, sub-pixel convolution, nearest-neighbor, and bilinear interpolation [10], [43], [61]. Odena et al. reported that checkerboard artifacts can occur for image generation tasks if the upsampling layers are not well selected [37]. Interestingly, while our method generates images by first estimating convolution kernels, these artifacts can still occur, as shown in Figure 3. We followed the suggestions of Odena et al. and handled these artifacts by using bilinear interpolation to perform the upsampling in the decoder of our network. Loss FunctionWe consider two types of loss functions that measure the difference between an interpolated frame I^ and its corresponding ground truth Igt. The first one is ℓ1 norm based on per-pixel color difference, as defined below. L1=∥∥I^−Igt∥∥1(2)View Source\begin{equation*}
\mathcal{L}_{1}=\left\Vert\hat{I}-I_{gt}\right\Vert_{1} \tag{2}
\end{equation*} Alternatively the ℓ2 norm can be used; however, we found it often leads to blurry results, as also reported in other image generation tasks [18], [30], [34], [39], [45]. The second type of loss functions that this work explores is perceptual loss, which has often been found effective in producing visually pleasing images [11], [22], [27], [42], [65]. Perceptual loss is usually based on high-level features of images and is defined as follows. LF=∥∥ϕ(I^)−ϕ(Igt)∥∥22(3)View Source\begin{equation*}
\mathcal{L}_{F}=\left\Vert\phi(\hat{I})-\phi(I_{gt})\right\Vert_{2}^{2} \tag{3}
\end{equation*} where ϕ extracts features from an image. We tried various loss functions based on different feature extractors, such as SSIM loss [40] and feature reconstruction loss [22]. We empirically found that the feature reconstruction loss based on the re1u4_4 layer of the VGG-19 network [44] produces good results for our frame interpolation task. 3.2. Training: We initialized our neural network parameters using a convolution aware initialization method [1] and trained it using AdaMax [25] with β1=0.9, β2=0.999, a learning rate of 0.001 and a mini-batch size of 16 samples. We chose a small mini-batch size since we experienced a degradation in the quality of the trained model as described by Keskar et al. [24] when using more samples per mini-batch. We used patches of size 128×128 instead of training on entire frames. This allows us to avoid patches that contain no useful information and leads to diverse mini-batches, which as described by Bansal et al. [4] improves training. Training DatasetWe extracted training samples from widely available videos, where each training sample consists of three consecutive frames with the middle frame serving as the ground truth. Since the video quality has a great influence on the quality of the trained model, we acquired video material from selected YouTube channels such as “Tom Scott”, “Casey Neistat”, “Linus Tech Tips”, and “Austin Evans”, whose videos consistently have a high-quality. Note that we downloaded these videos with a resolution of 1920×1080 but scale them to 1280×720 in order to reduce the influence of video compression. Following Niklaus et al. [36], we did not use samples that span across video shot boundaries and discarded samples with a lack of texture. To increase the diversity of our training dataset, we avoided samples that are temporally close to each other. Instead of using the full frames, we randomly cropped 150×150 patches and selected those with sufficiently large motion. To compute the motion in each sample, we estimated the mean optical flow between the first and the last patch using SimpleFlow [48]. We composed our dataset from the extracted samples by randomly selecting 250, 000 of them without replacement. The random selection was guided by the estimated mean optical flow, making sure that samples with a large flow magnitude were more likely to be included. Overall, 10% of the pixels in the resulting training dataset have a flow magnitude of at least 17 pixels and 5% of them have a magnitude of at least 23 pixels. The largest motion is 39 pixels. Data AugmentationWe performed data augmentation on the fly during training. While each sample in the training dataset is of size 150×150 pixels, we used patches with a size of 128×128 pixels for training. This makes it possible to perform data augmentation by random cropping, preventing the network from learning spatial priors that potentially exist in the training dataset. We augmented the motion of each sample by shifting the cropped windows in the first and last frames while leaving the cropped window of the ground truth unchanged. By doing this systematically and shifting the cropped windows of the first and last frames in opposite directions, the ground truth will still be sound. We found that performing shifts by up to 6 pixels works well, which augments the flow magnitude by approximately 8.5 pixels. We also randomly flipped the cropped patches horizontally or vertically and randomly swap their temporal order, which makes the motion within the training dataset symmetric and prevents the network from being biased. 3.3. Implementation Details: Below we discuss implementation details with respect to speed, boundary handling, and hyper-parameter selection. Computational EfficiencyWe used Torch [8] to implement our convolutional neural network. To achieve a high computational efficiency and allow our network to directly render the interpolated frame, we wrote our own layer in CUDA that applies the estimated 1D kernels. If applicable, we used implementations based on cuDNN [7] for the other layers of the network to further improve the speed. With a Nvidia Titan X (Pascal), our system is able to interpolate a 1280×720 frame in 0.5 seconds as well as a 1920×1080 frame in 0.9 seconds. Training our network takes about 20 hours using four Nvidia Titan X (Pascal). Boundary HandlingDue to the utilized convolution-based interpolation formulation, the input needs to be padded such that boundary pixels can be processed. We tried zero padding, reflective padding, and padding by repetition. Empirically, we found padding by repetition to work well and used it accordingly. Note that boundary handling is not needed during training, where an output with a reduced size is still acceptable. Hyper-Parameter SelectionWe used a validation dataset in order to select reasonable hyper-parameters for our network architecture as well as for the training. This validation dataset is disjoint from the training dataset but has been created in a similar manner. Besides common parameters such as the learning rate, our model comes with a crucial domain-specific hyperparameter, which is the size of the 1D kernels for interpolation. We found kernels of size 51 pixels to work well, which we attribute to the largest flow magnitude in the dataset, 39 pixels, together with 8.5-pixels of extra motion from augmentation. While increasing the kernel size is desirable to handle larger motion, restricted by the flow in our dataset, we did not observe improvements with larger kernels. Another important hyper-parameter for our method is the number of pooling layers. Pooling layers have a great influence on the receptive field [32] of a convolutional neural network, which in our context is related to the aperture problem in motion estimation. A larger number of pooling layers increases the receptive field to potentially handle large motion; on the other hand, the largest flow magnitude in the training dataset provides an upper bound for the number of useful pooling layers. Empirically, we found using five pooling layers produces good interpolation results. 

SECTION 4. Experiments: We compare our method with representative state-of-the-art methods and evaluate them both qualitatively and quantitatively. For the optical flow based methods, we selected MDP-Flow2 [56], which currently achieves the lowest interpolation error in the Middlebury benchmark and Deep-Flow2 [52], which is the neural network based approach with the lowest interpolation error [3]. We follow recent frame interpolation papers [29], [35] and use the algorithm from the Middlebury benchmark [3] to synthesize frames from the estimated optical flow. We also compare our method with the phase-based frame interpolation method from Meyer et al. [35] as well as the AdaConv method based on adaptive convolution from Niklaus et al. [36] as alternatives to optical flow based methods. For all these methods, we use the code or trained models from the original papers. Please refer to our video for more results. 4.1. Loss Functions: Our method incorporates two types of loss functions: L1 loss and feature reconstruction loss LF. To examine their effect, we trained two versions of our neural network. For the first one, we only used L1 loss and refer to this network as “L1” for simplicity in this paper. For the second one, we used both L1 loss and LF loss and refer to this network as “LF” for simplicity. We tried different training schemes, including using linear combinations of L1 and LF with different weights, and first training the network with L1 loss and then fine tuning it using LF loss. We found that the latter leads to the best visual quality and used this scheme accordingly. As shown in Figure 4, incorporating LF loss leads to sharper images with more high frequency details. This is in line with the findings in recent work on image generation and super resolution [11], [22], [27], [42], [65].
Figure 4: The effect of loss functions. 
4.2. Visual Comparison: We examine how our separable convolution approach handles challenging cases of video frame interpolation. The top row in Figure 5 shows an example where the delicate butterfly leg makes it difficult to estimate optical flow accurately, causing artifacts in the flow-based results. Since the leg motion is also large, the phase-based approach cannot handle it well either and produces ghosting artifacts. The result from AdaConv appears blurry. Both our results are sharp and free from ghosting artifacts. The second row shows an example of a busy street. As people are moving in opposing directions, there is significant occlusion. Both our methods handle occlusion better than the others. We attribute this to the convolution approach and the use of 1D kernels with fewer parameters. In the third row, we show an example of a stage where the rightmost spotlight is being turned on. This violates the brightness constancy assumption of optical flow methods, leading to visible artifacts in the frame interpolation results. The last row shows an example with shallow depth of field, which is common in professional videos. The blurry background makes flow estimation difficult and compromises the flow-based frame interpolation results. For these examples, the other methods, including ours, work well. KernelsWe examine how the kernels estimated by our LF method compare to those from AdaConv. We show some representative kernels in Figure 6. Note that we convolve each pair of 1D kernels from our method to produce its equivalent 2D kernel for comparison. As our kernels are larger than those from AdaConv, we cropped the boundary values off for better visualization as they are all zeros.
Figure 5: Visual comparison among frame interpolation methods. 
Figure 6: Comparison of the estimated kernels. 
In the butterfly example, we show the kernels for a pixel on the leg. AdaConv only takes color from the corresponding pixel in the second input frame. While our method takes color mainly from the same pixel in the second input, it also takes color from the corresponding pixel in the first input frame. Since the color of that pixel remains the same in the two input frames, both methods produce proper results. Notice how both methods capture the motion encoded as the offset of the non-zero kernel values to the kernel center. The second example shows kernels for a pixel in the lit area where the brightness changes between two input frames. Both methods output the same kernels that, due to the lack of motion, only have non-zero values in the center. Therefore, the output color is estimated as the average color of the corresponding pixels in the input frames. The last example shows a pixel in an occluded area due to the leaf moving up. This area is only visible in the second input frame and both methods produce kernels that correctly choose to only sample from the second frame. They thus produce good results and are able to handle occlusion appropriately, unlike methods that explicitly have to establish a correspondence between pixels of the input frames. 4.3. Quantitative Evaluation: We quantitatively evaluate our method on the interpolation set of the Middlebury optical flow benchmark [3]. Note that we did not fine-tune our models in any way. The results are shown in Table 1. Our L1 model and our LF model perform particularly well in the regions with discontinuous motion. In terms of overall average, our L1 model achieves state-of-the-art results. Notice that our LF model performs inferior to our L1 model in this quantitative evaluation due to its loss function that optimizes for perceptual quality.
Table 1: Evaluation on the middlebury benchmark. Disc.: Regions with discontinuous motion. Unt.: Textureless regions
Table 2: More extensive quantitative evaluation
For a more extensive quantitative evaluation, we performed a cross-validation and additionally assessed the interpolation capabilities of the different methods on a popular video. The results are shown in Table 2. For the former, we performed a 10-fold cross-validation on our training dataset for both of our methods and let the other methods directly interpolate the 250, 000 samples that each have a resolution of 150×150 pixels. Please note that this experiment is mainly to evaluate how our method can generalize. We did not adjust the parameters of the other methods or fine-tune them, which might limit their performance in this cross-validation experiment and we included them as baselines. For the latter, we obtained the video “See You Again” from Wiz Khalifa which currently is the most viewed video on YouTube. We processed this video at a size of 960×540 since this resolution is the largest that all methods and their reference implementations support. We withheld every other frame and used the remaining frames to interpolate the withheld ones. In this way, every method interpolated 2, 801 frames. Across these two additional experiments, our L1 model performs best regardless of the incorporated error metric. Like in the evaluation on the Middlebury benchmark, our LF model quantitatively performs inferior to our L1 model due to the nature of the different loss functions that they were optimized with. 4.4. User Study: We conducted a user study to further compare the visual quality of the frame interpolation results from our LF method with our L1 method as well as the other four methods. We recruited 15 participants, who are graduate or undergraduate students in Computer Science and Statistics. This study used all 8 examples of the Middlebury testing set. On each example, our LF result was compared to the other 5 results one by one. In this way, each participant compared 40 pairs of results. We developed a web-based system for the study. In each trial, the website only shows one result and supports participants to switch back and forth between two results using the arrow keys on the keyboard, allowing them to easily examine the difference between the results. The participants were asked to select the better result for each trial. The temporal order as well as the order in which the two results appear were randomized. Figure 7 shows the result of this study. For each hypothesis that users prefer the frames interpolated by our LF method over those produced by one of the baselines, we get a p-value < 0.01 and can thus confirm them. Note that the participants preferred our L1 result over our LF result on the Basketball example, shown in Figure 8. We attribute this to the introduced discontinuity to the basketball. 4.5. Comparison with Adaconv: Our method builds upon AdaConv [36] by estimating 1D kernels instead of 2D kernels and developing a dedicated encoder-decoder neural network to estimate the kernels for all the pixels in a frame at once. This provides a few advantages. First, our method is over 20 times faster than AdaConv when interpolating a 1080p video. Second, as shown in the previous quantitative comparisons (Table 1 and Table 2), our method produces numerically better results. Third, our methods, especially LF, often generates visually more appealing results than AdaConv as shown in Figure 5, 10, and in our study. We attribute these advantages to the separable convolution. First, it allows us to synthesize the full frame at once and to use perceptual loss that has recently been shown effective in producing visually pleasing results [11], [22], [27], [42], [65]. Second, 1D kernels require significantly fewer parameters, which enforces a useful constraint to obtain good kernels. Third, our method is able to use a larger kernel than AdaConv and can thus handle larger motion. As shown in Figure 9, AdaConv cannot capture the motion of the cars and generates blurry results. 4.6. Discussion: By using different loss functions, we effectively optimized our model for different goals. While our L1 approach is able to provide better numerical results as reported in the quantitative evaluation in Table 1 and 2, our LF approach achieves higher visual quality as shown in the user study where perceptual quality has been evaluated.
Figure 7: User study result. The error bars denote the standard deviation. 
Figure 8: Example where users prefer our L1 result. 
Figure 9: Comparison with adaconv and direct synthesis. 
One question that has so far been left unanswered is how interpolation via separable convolution compares to directly synthesizing frames using a neural network. Therefore, we adapted our network in order to obtain a baseline for direct synthesis. Specifically, we used one sub-network after the encoder-decoder and let it directly estimate the interpolated frame instead of the kernel coefficients. We furthermore added Batch Normalization [20] layers after each block of convolution layers, which improves the quality of this direct synthesis network. We trained this model in the same way we trained our LF method. As shown in Figure 9, the direct synthesis leads to blurry results. Additionally, we compare our approach with the image matching method from Long et al. [30] that performs direct synthesis to produce a middle frame as an intermediate result. As shown in Figure 10, our result is sharper. This is consistent with the findings in Zhou et al. [64] where they argue that synthesizing images from scratch is difficult. The amount of motion that our method can handle is limited by the kernel size, which is 51 pixels in our system. While this is larger than the recent AdaConv method [36], we plan to handle even larger motion by borrowing a multiscale approach from optical flow research [38]. Like AdaConv, our approach currently interpolates a frame at t=0.5 in the middle of the two input frames. We cannot produce a frame at an arbitrary time between the input ones. To address this, we could either recursively continue synthesizing frames at t=0.25 and t=0.75, or train a new model from scratch that returns frames at a different temporal offset. Both of these solutions are not ideal and are not as flexible as optical flow based interpolation. In the future, we plan to enhance our neural network to explicitly handle the temporal offset as a control variable.
Figure 10: Comparison with long et al. [30]. 


SECTION 5. Conclusion: This paper presents a practical solution to high-quality video frame interpolation. The presented method combines motion estimation and frame synthesis into a single convolution process by estimating spatially-adaptive separable kernels for each output pixel and convolving input frames with them to render the intermediate frame. The key to make this convolution approach practical is to use 1D kernels to approximate full 2D ones. The use of 1D kernels significantly reduces the number of kernel parameters and enables full-frame synthesis, which in turn supports the use of perceptual loss to further improve the visual quality of the interpolation results. Our experiments show that our method compares favorably to state-of-the-art interpolation results both quantitatively and qualitatively and produces high-quality frame interpolation results. 
ACKNOWLEDGMENTS: Figures 5 (top), 6 (top) are used with permission from Gabor Tarnok. The remaining images in Figure 5 are used under a Creative Commons license from Alberto Antoniazzi, Ursula Mann and the city of Nuremberg. Figures 1, 2, 3, 4, 6 (bottom), 10 originate from the Blender Foundation, while Figure 8 and Figure 9 originate from the Middlebury and the Kitti benchmark respectively. We thank Nvidia for their GPU donation. This work was supported by NSF IIS-1321119.