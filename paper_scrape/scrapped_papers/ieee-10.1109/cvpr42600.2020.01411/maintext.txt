SECTION 1. Introduction: Generative Adversarial Networks (GAN) [13] have emerged as one of the dominant unsupervised approaches for computer vision and beyond. Their strength relates to their remarkable ability to represent complex probability distributions, like the face manifold [33], or the bedroom images manifold [53], which they do by learning a generator map from a known distribution onto the data space. Just as important are the approaches that aim at learning an encoder map from the data to a latent space. They allow learning suitable representations of the data for the task at hand, either in a supervised [29], [46], [40], [14], [52], or unsupervised [37], [58], [19], [25], [4], [3] manner. Autoencoder (AE) [28], [41] networks are unsupervised approaches aiming at combining the “generative” as well as the “representational” properties by learning simultaneously an encoder-generator map. General issues subject of investigation in AE structures are whether they can: (a) have the same generative power as GANs; and, (b) learn disentangled representations [1]. Several works have addressed (a) [35], [31], [6], [9], [20]. An important testbed for success has been the ability for an AE to generate face images as rich and sharp as those produced by a GAN [23]. Progress has been made but victory has not been declared. A sizable amount of work has addressed also (b) [19], [25], [10], but not jointly with (a). We introduce an AE architecture that is general, and has generative power comparable to GANs while learning a less entangled representation. We observed that every AE approach makes the same assumption: the latent space should have a probability distribution that is fixed a priori and the autoencoder should match it. On the other hand, it has been shown in [24], the state-of-the-art for synthetic image generation with GANs, that an intermediate latent space, far enough from the imposed input space, tends to have improved disentanglement properties. The observation above has inspired the proposed approach. We designed an AE architecture where we allow the latent distribution to be learned from data to address entanglement (A). The output data distribution is learned with an adversarial strategy (B). Thus, we retain the generative properties of GANs, as well as the ability to build on the recent advances in this area. For instance, we can seamlessly include independent sources of stochasticity, which have proven essential for generating image details, or can leverage recent improvements on GAN loss functions, regularization, and hyperparameters tuning [2], [30], [38], [34], [36], [3]. Finally, to implement (A) and (B) we impose the AE reciprocity in the latent space (C). Therefore, we can avoid using reconstruction losses based on simple l2 norm that operate in data space, where they are often suboptimal, like for the image space. We regard the unique combination of (A), (B), and (C) as the major techical novelty and strength of the approach. Since it works on the latent space, rather than autoencoding the data space, we named it Adversarial Latent Autoencoder (ALAE). We designed two ALAEs, one with a multilayer perceptron (MLP) as encoder with a symmetric generator, and another with the generator derived from a StyleGAN [24], which we call StyleALAE. For this one, we designed a companion encoder and a progressively growing architecture. We verified qualitatively and quantitatively that both architectures learn a latent space that is more disentangled than the imposed one. In addition, we show qualitative and quantitative results about face and bedroom image generation that are comparable with StyleGAN at the highest resolution of 1024 × 1024. Since StyleALAE learns also an encoder network, we are able to show at the highest resolution, face reconstructions as well as several image manipulations based on real images rather then generated. 

SECTION 2. Related Work: Our approach builds directly on the vanilla GAN architecture [12]. Since then, a lot of progress has been made in the area of synthetic image generation. LAP-GAN [5] and StackGAN [55], [56] train a stack of GANs organized in a multi-resolution pyramid to generate high-resolution images. HDGAN [57] improves by incorporating hierarchically-nested adversarial objectives inside the network hierarchy. In [51] they use a multi -scale generator and discriminator architecture to synthesize high-resolution images with a GAN conditioned on semantic label maps, while in BigGAN [3] they improve the synthesis by applying better regularization techniques. In PGGAN [23] it is shown how high-resolution images can be synthesized by progressively growing the generator and the discriminator of a GAN. The same principle was used in StyleGAN [24], the current state-of-the-art for face image generation, which we adapt it here for our StyleALAE architecture. Other recent work on GANs has focussed on improving the stability and robustness of the training [44]. New loss functions have been introduced [2], along with gradient regularization methods [39], [36], weight normalization techniques [38], and learning rate equalization [23]. Our framework is amenable to these improvements, as we explain in later sections. Variational AE architectures [28], [41] have not only been appreciated for their theoretical foundation, but also for their stability during training, and the ability to provide insightful representations. Indeed, they stimulated research in the area of disentanglement [1], allowing learning representations with controlled degree of disentanglement between factors of variation in [19], and subsequent improvements in [25], leading to more elaborate metrics for disentanglement quantification [10], [4], [24], which we also use to analyze the properties of our approach. VAEs have also been extended to learn a latent prior different than a normal distribution, thus achieving significantly better models [48]. A lot of progress has been made towards combining the benefits of GANs and VAEs. AAE [35] has been the precursor of those approaches, followed by VAE/GAN [31] with a more direct approach. BiGAN [6] and ALI [9] provide an elegant framework fully adversarial, whereas VEE-GAN [47] and AGE [49] pioneered the use of the latent space for autoencoding and advocated the reduction of the architecture complexity. PIONEER [15] and IntroVAE [20] followed this line, with the latter providing the best generation results in this category. Section 4.1 describes how the proposed approach compares with those listed here. Finally, we quickly mention other approaches that have shown promising results with representing image data distributions. Those include autoregressive [50] and flow-based methods [27]. The former forego the use of a latent representation, but the latter does not. 

SECTION 3. Preliminaries: A Generative Adversarial Network (GAN) [13] is composed of a generator network G mapping from a space Z onto a data space X, and a discriminator network D mapping from X onto R. The Z space is characterized by a known distribution p(z). By sampling from p(z), the generator G produces data representing a synthetic distribution q(x). Given training data D drawn from a real distribution pD(x), a GAN network aims at learning G so that q(x) is as close to pD(x) as possible. This is achieved by setting up a zero-sum two-players game with the discriminator D. The role of D is to distinguish in the most accurate way data coming from the real versus the synthetic distribution, while G tries to fool D by generating synthetic data that looks more and more like real. Following the more general formulation introduced in [39], the GAN learning problem entails finding the minimax with respect to the pair (G, D) (i.e., the Nash equilibrium), of the value function defined asV(G, D)=EpD(x)[f(D(x))]+Ep(z)[f(−D(G(z)))],(1)View Source\begin{equation*}
V(\mathrm{G},\ \mathrm{D})=E_{p_{D}(x)}[f(\mathrm{D}(x))]+E_{p(z)}[f(-\mathrm{D}(\mathrm{G}(z)))],
\tag{1}
\end{equation*} where E[⋅] denotes expectation, and f:R→]R is a concave function. By setting f(t)=−log(1+exp(−t)) we obtain the original GAN formulation [13]; instead, if f(t)=t we obtain the Wasserstein GAN [2]. 

SECTION 4. Adversarial Latent Autoencoders: We introduce a novel autoencoder architecture by modifying the original GAN paradigm. We begin by decomposing the generator G and the discriminator D in two networks: F,G, and E,D, respectively. This means thatG=GoF,and D=DoE,(2)View Source\begin{equation*}
\mathrm{G}=G\mathrm{o}F, \mathrm{and} \ \mathrm{D}=D\mathrm{o}E,
\tag{2}
\end{equation*} see Figure 1. In addition, we assume that the latent spaces at the interface between F and G, and between E and D are the same, and we indicate them as W. In the most general case we assume that F is a deterministic map, whereas we allow E and G to be stochastic. In particular, we assume that G might optionally depend on an independent noisy input η, with a known fixed distribution pη(η). We indicate with G(w, η) this more general stochastic generator.
Figure 1: ALAE architecture. Architecture of an adversarial latent autoencoder. 
Under the above conditions we now consider the distributions at the output of every network. The network F simply maps p(z) onto qF(w). At the output of G the distribution can be written asq(x)=∫w∫ηqG(x|w, η)qF(w)pη(η)dηdw,(3)View Source\begin{equation*}
q(x)= \int_{w}\int_{\eta}q_{G}(x\vert w,\ \eta)q_{F}(w)p_{\eta}(\eta)\mathrm{d}\eta \mathrm{d}w,
\tag{3}
\end{equation*} where qG(x|w, η) is the conditional distribution representing G. Similarly, for the output of E the distribution becomesqE(w)=∫xqE(w|x)q(x)dx,(4)View Source\begin{equation*}
q_{E}(w)= \int_{x}q_{E}(w\vert x)q(x)\mathrm{d}x,
\tag{4}
\end{equation*} where qE(w|x) is the conditional distribution representing E. In (4) if we replace q(x) with p_{D}(x) we obtain the distribution q_{E,\mathcal{D}}(w), which describes the output of E when the real data distribution is its input. Since optimizing (1) leads toward the synthetic distribution matching the real one, i.e., q(x)=p_\mathcal{D}(x), it is obvious from (4) that doing so also leads toward having {qE} (w)=qE\cdot \mathcal{D}(w). In addition to that, we propose to ensure that the distribution of the output of E be the same as the distribution at the input of G. This means that we set up an additional goal, which requires that\begin{equation*}
q_{F}(w)=q_{E}(w).
\tag{5}
\end{equation*}View Source\begin{equation*}
q_{F}(w)=q_{E}(w).
\tag{5}
\end{equation*} In this way we could interpret the pair of networks (G, E) as a generator-encoder network that autoencodes the latent space \mathcal{W}. If we indicate with A (p\Vert q) a measure of discrepancy between two distributions p and q, we propose to achieve the goal (5) via regularizing the GAN loss (1) by alternating the following two optimizations\begin{align*}
\min_{F,G}\max_{E,D}V(G\mathrm{o}F,\ D\mathrm{o}E)\\
\tag{6}\\
\min_{E,G}\Delta(F\Vert E\circ G\circ F)
\tag{7}
\end{align*}View Source\begin{align*}
\min_{F,G}\max_{E,D}V(G\mathrm{o}F,\ D\mathrm{o}E)\\
\tag{6}\\
\min_{E,G}\Delta(F\Vert E\circ G\circ F)
\tag{7}
\end{align*} where the left and right arguments of \Delta indicate the distributions generated by the networks mapping \mathrm{p}(z), which correspond to q_{F}(w) and q_{E}(w), respectively. We refer to a network optimized according to (6) (7) as an Adversarial Latent Autoencoder (ALAE). The building blocks of an ALAE architecture are depicted in Figure 1.
Table 1: Autoencoder real to the synthetic the latent achieved
4.1. Relation with Other Autoencoders: Data distribution In architectures composed by an en-coder network and a generator network, the task of the encoder is to map input data onto a space characterized by a latent distribution, whereas the generator is tasked to map latent codes onto a space described by a data distribution. Different strategies are used to learn the data distribution. For instance, some approaches impose a similarity criterion on the output of the generator [28], [41], [35], [48], or even learn a similarity metric [31]. Other techniques instead, set up an adversarial game to ensure the generator output matches the training data distribution [6], [9], [47], [49], [20]. This latter approach is what we use for ALAE. Latent distribution For the latent space instead, the common practice is to set a desired target latent distribution, and then the encoder is trained to match it either by minimizing a divergence type of similarity [28], [41], [31], [47], [48], or by setting up an adversarial game [35], [6], [9], [49], [20]. Here is where ALAE takes a fundamentally different approach. Indeed, we do not impose the latent distribution, i.e., q_{E}(w), to match a target distribution. The only condition we set, is given by (5). In other words, we do not want F to be the identity map, and are very much interested in letting the learning process decide what F should be. Reciprocity Another aspect of autoecoders is whether and how they achieve reciprocity. This property relates to the ability of the architecture to reconstruct a data sample x from its code w, and viceversa. Clearly, this requires that x=G(E(x)), or equivalently that w=E(G(w)). In the first case, the network must contain a reconstruction term that operates in the data space. In the latter one, the term operates in the latent space. While most approaches follow the first strategy [28], [41], [35], [31], [20], [48], there are some that implement the second [47], [49], including ALAE. Indeed, this can be achieved by choosing the divergence in (7) to be the expected coding reconstruction error, as follows\begin{equation*}
\Delta(F\Vert E\circ G\circ F)= E_{p(z)}[\Vert F(z)-E\circ G\circ F(z)\Vert_{2}^{2}]
\tag{8}
\end{equation*}View Source\begin{equation*}
\Delta(F\Vert E\circ G\circ F)= E_{p(z)}[\Vert F(z)-E\circ G\circ F(z)\Vert_{2}^{2}]
\tag{8}
\end{equation*}
Figure 2: Stylealae architecture. The stylealae encoder has instance normalization (in) layers to extract multiscale style information that is combined into a latent code w via a learnable multilinear map. 
Imposing reciprocity in the latent space gives the significant advantage that simple \ell_{2}, \ell_{1} or other norms can be used effectively, regardless of whether they would be inappropriate for the data space. For instance, it is well known that element-wise \ell_{2} norm on image pixel differences does not reflect human visual perception. On the other hand, when used in latent space its meaning is different. For instance, an image translation by a pixel could lead to a large \ell_{2} discrepancy in image space, while in latent space its representation would hardly change at all. Ultimately, using ell_{2} in image space has been regarded as one of the reasons why autoencoders have not been as successful as GANs in re-constructing/generating sharp images [31]. Another way to address the same issue is by imposing reciprocity adversarially, as it was shown in [6], [9]. Table 1 reports a summary of the main characteristics of most of the recent generator-encoder architectures. 

SECTION 5. Stylealae: We use ALAE to build an autoencoder that uses a Style-GAN based generator. For this we make our latent space \mathcal{W} play the same role as the intermediate latent space in [24]. Therefore, our G network becomes the part of StyleGAN depicted on the right side of Figure 2. The left side is a novel architecture that we designed to be the encoder E. Since at every layer, G is driven by a style input, we design E symmetrically, so that from a corresponding layer we extract style information. We do so by inserting Instance Normalization (IN) layers [21], which provide instance averages and standard deviations for every channel. Specifically, if y_{i}^{E} is the output of the i-\text{th} layer of E, the IN mod- ule extracts the statistics \mu(y_{i}^{E}) and \sigma(y_{i}^{E}) representing the style at that level. The IN module also provides as output the normalized version of the input, which continues down the pipeline with no more style information from that level. Given the information flow between E and G, the architecture is effectively mimicking a multiscale style transfer from E to G, with the difference that there is not an extra input image that provides the content [21], [22]. The set of styles that are inputs to the Adaptive Instance Normalization (AdaIN) layers [21] in G are related linearly to the latent variable w. Therefore, we propose to combine the styles output by the encoder, and to map them onto the latent space, via the following multilinear map\begin{equation*}
w= \sum_{i=1}^{N}C_{i}[_{\sigma(y_{i}^{E})}^{\mu(y_{i}^{E})}]
\tag{9}
\end{equation*}View Source\begin{equation*}
w= \sum_{i=1}^{N}C_{i}[_{\sigma(y_{i}^{E})}^{\mu(y_{i}^{E})}]
\tag{9}
\end{equation*} where the C_{i}'s are learnable parameters, and N is the number of layers. Similarly to [23], [24] we use progressive growing. We start from low-resolution images (4 × 4 pixels) and progressively increase the resolution by smoothly blending in new blocks to E and G. For the F and D networks we implement them using MLPs. The \mathcal{Z} and \mathcal{W} spaces, and all layers of F and D have the same dimensionality in all our experiments. Moreover, for StyleALAE we follow [24], and chose F to have 8 layers, and we set D to have 3 layers. 

SECTION 6. Implementation: Adversarial losses and regularization We use a non-saturating loss [13], [36], which in (1) we introduce by setting f(\cdot) to be a SoftPlus function [11]. This is a smooth version of the rectifier activation function, defined as f(t) = softplus (t)=\log(1+\exp(t)). In addition, we use gradient regularization techniques [8], [36], [43]. We utilize R_{1} [44], [36], a zero-centered gradient penalty term which acts only on real data, and is defined as \frac{\gamma}{2}\mathrm{E}_{p\mathcal{D}}(x)[\Vert\nabla D\mathrm{o}E(x)\Vert^{2}], where the gradient is taken with respect to the parameters \theta_{E} and \theta_{D} of the networks E and D, respectively.

SECTION Algorithm 1 ALAE Training: 1:\theta_{F}, \theta_{G}, \theta_{B}, \theta_{D}\leftarrow Initialize network parameters 2:while not converged do 3:Step I. Update E, and D 4:x\leftarrow Random mini-batch from dataset 5:z\leftarrow Samples from prior \mathcal{N}(0,1) 6:L_{adv}^{E,D}\leftarrow softplus (D\mathrm{o}E\mathrm{o}G\mathrm{o}F(z)))+ \mathrm{softplus} (-D\mathrm{o}E(x))+\\\frac{\gamma}{2}{\mathrm{E}_{pD(x)}}[\Vert\nabla D\mathrm{o}E(x)\Vert^{2}]\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad 7:\theta_{E}, \theta_{\mathrm{D}}\leftarrow ADAM (\nabla_{\theta_{D}}\theta_{E}L^{E,D_{adv},}\theta_{D},\theta_{E},\alpha,\beta_{1}.\beta_{2}) 8:Step II. Update F, and {G} 9:z\leftarrow Samples from prior \mathcal{N}(0, I) 10:L_{adv}^{F,G}\leftarrow softplus (-D\mathrm{o}E\mathrm{o}G\mathrm{o}F(z))) 11:\theta_{F}, \theta_{G}\leftarrow ADAM (\nabla_{\theta_{\mathrm{E},\theta_{G}\mathrm{L}^{F,G}_{adv},}} \theta_{F},\ \theta_{G},\ \alpha,\ \beta_{1},\ \beta_{2}) 12:Step III. Update E, and G 13:Z\leftarrow Samples from prior \mathcal{N}(0,1) 14:L_{error}^{E,G}\rightarrow\succ\Vert F(z)-E\mathrm{o}G\mathrm{o}F(z)\Vert_{2}^{2} 15:\theta_{E}, \theta_{G}\leftarrow ADAM (\nabla_{\theta_{E},\theta_{\mathrm{G}}}L_{error}^{E,\mathrm{G}},\ \theta_{E},\ \theta_{G},\ \alpha,\ \beta_{1},\ \beta_{2}) 16:end while 
Figure 3: MNIST reconstruction. Reconstructions of the permutation-invariant mnist. Top row: real images. Middle row: bigan reconstructions. Bottom row: ALAE reconstructions. The same MLP architecture is used in both methods. 
Training In order to optimizate (6) (7) we use alternating updates. One iteration is composed of three updating steps: two for (6) and one for (7). Step I updates the discriminator (i.e., networks E and D). Step II updates the generator (i.e., networks F and G). Step III updates the latent space autoencoder (i.e., networks G and E). The procedural details are summarized in Algorithm 1. For updating the weights we use the Adam optimizer [26] with \beta_{1}=0.0 and \beta_{2}=0.99, coupled with the learning rate equalization technique [23] described below. For non-growing architectures (i.e., MLPs) we use a learning rate of 0.002, and batch size of 128. For growing architectures (i.e., StyleALAE) learning rate and batch size depend on the resolution. 

SECTION 7. Experiments: Code and uncompressed images are available at https://github.com/podgorskiy/ALAE. 7.1. Representation Learning with MLP: We train ALAE with MNIST [32], and then use the feature representation for classification, reconstruction, and analyzing disentanglement. We use the permutation-invariant setting, where each 28 × 28 MNIST image is treated as a 784D vector without spatial structure, which requires to use a MLP instead of a CNN. We follow [7] and use a three layer MLP with a latent space size of 50D. Both networks, E and G have two hidden layers with 1024 units each. In [7] the features used are the activations of the layer before the last of the encoder, which are 1024D vectors. We refer to those as long features. We also use, as features, the 50D vectors taken from the latent space, \mathcal{W}. We refer to those as short features.
Figure 4: MNIST traversal. Reconstructions of the interpolations in the \mathcal{Z} space, and the \mathcal{W} space, between the same digits. The latter transition appears to be smoother. 
Table 2: MNIST classification. Classification accuracy (%) on the permutation-invariant MNIST [32] using 1NN and linear SVM, with same writers (sw) and different writ-ers (dw) settings, and short features (sf) vs. Long features (1f), indicated as sf/lf
MNIST has an official split into training and testing sets of sizes 60000 and 10000 respectively. We refer to it as different writers (DW) setting since the human writers of the digits for the training set are different from those who wrote the testing digits. We consider also a same writers (SW) setting, which uses only the official training split by further splitting it in two parts: a train split of size 50000 and a test split of size 10000, while the official testing split is ignored. In SW the pools of writers in the train and test splits overlap, whereas in DW they do not. This makes SW an easier setting than DW. Results We report the accuracy with the 1NN classifier as in [7], and extend those results by reporting also the accuracy with the linear SVM, because it allows a more direct analysis of disentanglement. Indeed, we recall that a disentangled representation [45], [42], [1] refers to a space consisting of linear subspaces, each of which is responsible for one factor of variation. Therefore, a linear classifier based on a disentangled feature space should lead to better performance compared to one working on an entangled space. Table 2 summarizes the average accuracy over five trials for ALAE, BiGAN, as well as the following baselines proposed in [7]: Latent Regressor (LR), Joint Latent Regressor (JLR), Autoencoders trained to minimize the ell_{2}(\text{AE}(\ell_{2})) or the \ell_{1} (\text{AE}(\ell_{1})) reconstruction error. The most significant result of Table 2 is drawn by comparing the 1NN with the corresponding linear SVM columns. Since 1NN does not presume disentanglement in order to be effective, but linear SVM does, larger performance drops signal stronger entanglement. ALAE is the approach that remains more stable when switching from 1NN to linear SVM, suggesting a greater disentanglement of the space. This is true especially for short features, whereas for long features this effect fades away because linear separability grows. We also note that ALAE does not always provide the best accuracy, and the baseline AE (especially \text{AE}(\ell_{2}) does well with 1NN, and more so with short features. This might be explained by the baseline AE learning a representation that is closer to a discriminative one. Other approaches instead focus more on learning representations for drawing synthetic random samples, which are likely richer, but less discriminative. This effect also fades for longer features.
Table 3: FID scores. FID scores (lower is better) measured on FFHQ [24] and LSUN bedroom [54]
Another observation is about SW vs. DW. 1NN generalizes less effectively for DW, as expected, but linear SVM provides a small improvement. This is unclear, but we speculate that DW might have fewer writers in the test set, and potentially slightly less challenging. Figure 3 shows qualitative reconstruction results. It can be seen that BiGAN reconstructions are subject to semantic label flipping much more often than ALAE. Finally, Figure 4 shows two traversals: one obtained by interpolating in the \mathcal{Z} space, and the other by interpolating in the \mathcal{W} space. The second shows a smoother image space transition, suggesting a lesser degree of entanglement. 7.2. Learning Style Representations: FFHQ We evaluate StyleALAE with the FFHQ [24] dataset. It is very recent and consists of 70000 images of people faces aligned and cropped at resolution of 1024 × 1024. In contrast to [24], we split FFHQ into a training set of 60000 images and a testing set of 10000 images. We do so in order to measure the reconstruction quality for which we need images that were not used during training. We implemented our approach with PyTorch. Most of the experiments were conducted on a machine with 4 x GPU Titan X, but for training the models at resolution 1024 × 1024 we used a server with 8 × GPU Titan RTX. We trained StyleALAE for 147 epochs, 18 of which were spent at resolution 1024 × 1024. Starting from resolution 4 × 4 we grew StyleALAE up to 1024 × 1024. When growing to a new resolution level we used 500k training samples during the transition, and another 500k samples for training stabilization. Once reached the maximum resolution of 1024 × 1024, we continued training for 1M images. Thus, the total training time measured in images was 10M. In contrast, the total training time for StyleGAN [24] was 25M images, and 15M of them were used at resolution 1024 × 1024. At the same resolution we trained StyleALAE with only 1M images, so, 15 times less. Table 3 reports the FID score [18] for generations and reconstructions. Source images for reconstructions are from the test set and were not used during training. The scores of StyleALAE are higher, and we regard the large training time difference between StyleALAE and StyleGAN (1M vs 15M) as the likely cause of the discrepancy.
Table 4: Ppl. Perceptual path lengths on FFHQ measured in the \mathcal{Z} and the \mathcal{W} spaces (lower is better)
Table 4 reports the perceptual path length (PPL) [24] of SyleALAE. This is a measurement of the degree of disentanglement of representations. We compute the values for representations in the \mathcal{W} and the \mathcal{Z} space, where StyleALAE is trained with style mixing in both cases. The StyleGAN score measured in \mathcal{Z} corresponds to a traditional network, and in \mathcal{W} for a style-based one. We see that the PPL drops from \mathcal{Z} to \mathcal{W}, indicating that \mathcal{W} is perceptually more linear than \mathcal{Z}, thus less entangled. Also, note that for our models the PPL is lower, despite the higher FID scores. Figure 6 shows a random collection of generations obtained from StyleALAE. Figure 5 instead shows a collection of reconstructions. In Figure 9 instead, we repeat the style mixing experiment in [24], but with real images as sources and destinations for style combinations. We note that the original images are faces of celebrities that we downloaded from the internet. Therefore, they are not part of FFHQ, and come from a different distribution. Indeed, FFHQ is made of face images obtained from Flickr.com depicting non-celebrity people. Often the faces do not wear any makeup, neither have the images been altered (e.g., with Photoshop). Moreover, the imaging conditions of the FFHQ acquisitions are very different from typical photoshoot stages, where professional equipment is used. Despite this change of image statistics, we observe that StyleALAE works effectively on both reconstruction and mixing. LSUN We evaluated StyleALAE with LSUN Bed-room [54]. Figure 7 shows generations and reconstructions from unseen images during training. Table 3 reports the FID scores on the generations and the reconstructions.
Figure 5: FFHQ reconstructions. Reconstructions of unseen images with stylealae trained on FFHQ [24] at 1024 × 1024. 
Figure 6: FFHQ generations. Generations with stylealae trained on FFHQ [24] at 1024 × 1024. 
Figure 7: LSUN generations and reconstructions. Generations (first row), and reconstructions using stylealae trained on LSUN bedroom [54] at resolution 256 × 256. 
Table 5: Comparison of FID and PPL scores for celeba-hq images at 256 × 256 (lower is better). FID is based on 50,000 generated samples compared to training samples
CelebA-HQ CelebA-HQ [23] is an improved subset of CelebA [33] consisting of 30000 images at resolution 1024 × 1024. We follow [16], [17], [27], [23] and use CelebA-HQ downscaled to 256 × 256 with training/testing split of 27000/3000. Table 5 reports the FID and PPL scores, and Figure 8 compares StyleALE reconstructions of unseen faces with two other approaches. 

SECTION 8. Conclusions: We introduced ALAE, a novel autoencoder architecture that is simple, flexible and general, as we have shown to be efective with two very different backbone generator-encoder networks. Differently from previous work it allows learning the probability distribution of the latent space, when the data distribution is learned in adversarial settings. Our experiments confirm that this enables learning representations that are likely less entangled. This allows us to extend StyleGAN to StyleALAE, the first autoencoder capable of generating and manipulating images in ways not possible with SyleGAN alone, while maintaining the same level of visual detail.
Figure 8: Celeba-hq reconstructions. Celeba-hq reconstructions of unseen samples at resolution 256 × 256. Top row: real images. Second row: stylealae. Third row: balanced PIONEER [17]. Last row: PIONEER [16]. Stylealae reconstructions look sharper and less distorted. 
Figure 9: Two sets of real images were picked to form the source set and the destination set. The rest of the images were generated by copying specified subset of styles from the source set into the destination set. This experiment repeats the one from [24], but with real images. Copying the coarse styles brings high-level aspects such as pose, general hair style, and face shape from source set, while all colors (eyes, hair, lighting) and finer facial features resemble the destination set. Instead, if we copy middle styles from the source set, we inherit smaller scale facial features like hair style, eyes open/closed from source, while the pose, and general face shape from destination are preserved. Finally, copying the fine styles from the source set brings mainly the color scheme and microstructure. 

ACKNOWLEDGMENTS: This material is based upon work supported by the National Science Foundation under Grants No. OIA-1920920, and OAC-1761792.