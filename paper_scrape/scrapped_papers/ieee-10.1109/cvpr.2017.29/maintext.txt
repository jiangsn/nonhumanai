SECTION 1. Introduction: Matching 3D geometry has a long history starting in the early days of computer graphics and vision. With the rise of commodity range sensing technologies, this research has become paramount to many applications including object pose estimation, object retrieval, 3D reconstruction, and camera localization. However, matching local geometric features in low-resolution, noisy, and partial 3D data is still a challenging task as shown in Fig. 1. While there is a wide range of low-level hand-crafted geometric feature descriptors that can be used for this task, they are mostly based on signatures derived from histograms over static geometric properties [18], [21], [27]. They work well for 3D models with complete surfaces, but are often unstable or inconsistent in real-world partial surfaces from 3D scanning data and difficult to adapt to new datasets. As a result, state-of-the-art 3D reconstruction methods using these descriptors for matching geometry require significant algorithmic effort to handle outliers and establish global correspondences [5].
Figure 1. In this work, we present a data-driven local descriptor 3DMatch that establishes correspondences (green) to match geometric features in noisy and partial 3D scanning data. This figure illustrates an example of bringing two RGB-D scans into alignment using 3DMatch on depth information only. Color images are for visualization only. 
In response to these difficulties, and inspired by the recent success of neural networks, we formulate a data-driven method to learn a local geometric descriptor for establishing correspondences between partial 3D data. The idea is that by learning from example, data-driven models can sufficiently address the difficulties of establishing correspondences between partial surfaces in 3D scanning data. To this end, we present a 3D convolutional neural network (ConvNet), called 3DMatch, that takes in the local volumetric region (or 3D patch) around an arbitrary interest point on a 3D surface and computes a feature descriptor for that point, where a smaller distance between two descriptors indicates a higher likelihood of correspondence. However, optimizing a 3D ConvNet-based descriptor for this task requires massive amounts of training data (i.e., ground truth matches between local 3D patches). Obtaining this training data with manual annotations is a challenging endeavor. Unlike 2D image labels, which can be effectively crowd-sourced or parsed from the web, acquiring ground truth correspondences by manually clicking keypoint pairs on 3D partial data is not only time consuming but also prone to errors.
Figure 2. Learning 3DMatch from reconstructions. From existing RGB-D reconstructions (a), We extract local 3D patches and correspondence labels from scans of different views (b). We collect pairs of matching and non-matching local 3D patches and convert into a volumetric representation (c) To train a 3D convnet-based descriptor (d). This geometric descriptor can be used to establish correspondences for matching 3D geometry in various applications (e) Such as reconstruction, model alignment, and surface correspondence. 
Our key idea is to amass training data by leveraging correspondence labels found in existing RGB-D scene reconstructions. Due to the importance of 3D reconstructions, there has been much research on designing algorithms and systems that can build high-fidelity reconstructions from RGB-D data [24], [25], [8]. Although these reconstructions have been used for high-level reasoning about the environment [38], [39], it is often overlooked that they can also serve as a massive source of labeled correspondences between 3D surfaces of aligned depth frames. By training on correspondences from multiple existing RGB-D reconstruction datasets, each with its own properties of sensor noise, occlusion patterns, variance of geometric structures, and variety of camera viewpoints, we can optimize 3DMatch to generalize and robustly match local geometry in real-world partial 3D data. In this paper, we train 3DMatch over 8 million correspondences from a collection of 62 RGB-D scene reconstructions [36], [30], [39], [20], [15] and demonstrate its ability to match 3D data in several applications. Results show that 3DMatch is considerably better than state-of-the-art methods at matching keypoints, and outperforms other algorithms for geometric registration when combined with standard RANSAC. Furthermore, we demonstrate that 3DMatch can also generalize to different tasks and spatial resolutions. For example, we utilize 3DMatch to obtain instance-level model alignments for 6D object pose estimation as well as to find surface correspondences in 3D meshes. To facilitate further research in the area of 3D keypoint matching and geometric registration, we provide a correspondence matching benchmark as well as a surface registration benchmark similar to [5], but with real-world scan data. 

SECTION 2. Related Work: Learning local geometric descriptors for matching 3D data lies at the intersection of computer vision and graphics. We briefly review the related work in both domains. Hand-Crafted 3D Local Descriptors: Many geometric descriptors have been proposed including Spin Images [18], Geometry Histograms [12], and Signatures of Histograms [34], Feature Histograms [28]. Many of these descriptors are now available in the Point Cloud Library [3]. While these methods have made significant progress, they still struggle to handle noisy, low-resolution, and incomplete real-world data from commodity range sensors. Furthermore, since they are manually designed for specific applications or 3D data types, it is often difficult for them to generalize to new data modalities. The goal of our work is to provide a new local 3D descriptor that directly learns from data to provide more robust and accurate geometric feature matching results in a variety of settings. Learned 2D Local Descriptors: The recent availability of large-scale labeled image data has opened up new opportunities to use data-driven approaches for designing 2D local image patch descriptors. For instance, various works [32], [31], [40], [16], [41], [16] learn non-linear mappings from local image patches to feature descriptors. Many of these prior works are trained on data generated from multi-view stereo datasets [4]. However, in addition to being limited to 2D correspondences on images, multi-view stereo is difficult to scale up in practice and is prone to error from missing correspondences on textureless or non-Lambertian surfaces, so it is not suitable for learning a 3D surface descriptor. A more recent work [29] uses RGB-D reconstructions to train a 2D descriptor, while we train a 3D geometric descriptor. Learned 3D Global Descriptors: There has also been rapid progress in learning geometric representations on 3D data. 3D ShapeNets [38] introduced 3D deep learning for modeling 3D shapes, and several recent works [22], [11], [33] also compute deep features from 3D data for the task of object retrieval and classification. While these works are inspiring, their focus is centered on extracting features from complete 3D object models at a global level. In contrast, our descriptor focuses on learning geometric features for real-world RGB-D scanning data at a local level, to provide more robustness when dealing with partial data suffering from various occlusion patterns and viewpoint differences. Learned 3D Local Descriptors: More closely related to this work is Guo et al. [14], which uses a 2D ConvNet descriptor to match local geometric features for mesh labeling. However, their approach operates only on synthetic and complete 3D models, while using ConvNets over input patches of concatenated feature vectors that do not have any kind of spatial correlation. In contrast, our work not only tackles the harder problem of matching real-world partial 3D data, but also properly leverages 3D ConvNets on volumetric data in a spatially coherent way. Self-Supervised Deep Learning: Recently, there has been significant interest in learning powerful deep models using automatically-obtained labels. For example, recent works show that the temporal information from videos can be used as a plentiful source of supervision to learn embeddings that are useful for various tasks [13], [26]. Other works show that deep features learned from egomotion supervision perform better than features using class-labels as supervision for many tasks [2]. Analogous to these recent works in self-supervised learning, our method of extracting training data and correspondence labels from existing RGB-D reconstructions online is fully automatic, and does not require any manual labor or human supervision. 

SECTION 3. Learning from Reconstructions: In this paper, our goal is to create a function ψ that maps the local volumetric region (or 3D patch) around a point on a 3D surface to a descriptor vector. Given any two points, an ideal function ψ maps their local 3D patches to two descriptors, where a smaller ℓ2 distance between the descriptors indicates a higher likelihood of correspondence. We learn the function ψ by making use of data from existing high quality RGB-D scene reconstructions. The advantage of this approach is threefold: First, reconstruction datasets can provide large amounts of training correspondences since each reconstruction contains millions of points that are observed from multiple different scanning views. Each observation pair provides a training example for matching local geometry. Between different observations of the same interest point, its local 3D patches can look very different due to sensor noise, viewpoint variance, and occlusion patterns. This helps to provide a large and diverse correspondence training set. Second, reconstructions can leverage domain knowledge such as temporal information and well-engineered global optimization methods, which can facilitate wide baseline registrations (loop closures). We can use the correspondences from these challenging registrations to train a powerful descriptor that can be used for other tasks where the aforementioned domain knowledge is unavailable. Third, by learning from multiple reconstruction datasets, we can optimize 3DMatch to generalize and robustly match local geometry in real-world partial 3D data under a variety of conditions. Specifically, we use a total of over 200K RGB-D images of 62 different scenes collected from Analysis-by-Synthesis [36], 7-Scenes [30], SUN3D [39], RGB-D Scenes v.2 [20], and Halber et al. [15]. 54 scenes are used for training and 8 scenes for testing. Each of the reconstruction datasets are captured in different environments with different local geometries at varying scales and built with different reconstruction algorithms. 3.1. Generating Training Correspondences: To obtain training 3D patches and their ground truth correspondence labels (match or non-match), we extract local 3D patches from different scanning views around interest points randomly sampled from reconstructions. To find correspondences for an interest point, we map its 3D position in the reconstruction into all RGB-D frames for which the 3D point lies within the frame's camera view frustum and is not occluded. The locations of the cameras from which the RGB-D frames are taken are enforced to be at least 1m apart, so that the views between observation pairs are sufficiently wide-baselined. We then extract two local 3D patches around the interest point from two of these RGB-D frames, and use them as a matching pair. To obtain nonmatching pairs, we extract local 3D patches from randomly picked depth frames of two interest points (at least 0.1m apart) randomly sampled from the surface of the reconstruction. Each local 3D patch is converted into a volumetric representation as described in Sec. 4.1. Due to perturbations from depth sensor noise and imperfections in reconstruction results, the sampled interest points and their surrounding local 3D patches can experience some minor amounts of drift. We see this jitter as an opportunity for our local descriptor to learn small amounts of translation invariance. Since we are learning from RGB-D reconstruction datasets using different sensors and algorithms, the jitter is not consistent, which enables the descriptor to generalize and be more robust to it. 

SECTION 4. Learning a Local Geometric Descriptor: We use a 3D ConvNet to learn the mapping from a volumetric 3D patch to an 512-dimensional feature representation that serves as the descriptor for that local region. During training, we optimize this mapping (i.e., updating the weights of the ConvNet) by minimizing the ℓ2 distance between descriptors generated from corresponding interest points (matches), and maximize the ℓ2 distance between descriptors generated from non-corresponding interest points (non-matches). This is equivalent to training a ConvNet with two streams (i.e., Siamese Style ConvNets [6]) that takes in two local 3D patches and predicts whether or not they correspond to each other. 4.1. 3D Data Representation: For each interest point, we first extract a 3D volumetric representation for the local region surrounding it. Each 3D region is converted from its original representation (surface mesh, point cloud, or depth map) into a volumetric 30×30×30 voxel grid of Truncated Distance Function (TDF) values. Analogous to 2D pixel image patches, we refer to these TDF voxel grids as local 3D patches. In our experiments, these local 3D patches spatially span 0.3m3, where voxel size is 0.01m3. The voxel grid is aligned with respect to the camera view. If camera information is unavailable (i.e. for pre-scanned 3D models), the voxel grid is aligned to the object coordinates. The TDF value of each voxel indicates the distance between the center of that voxel to the nearest 3D surface. These TDF values are truncated, normalized and then flipped to be between 1 (on surface) and 0 (far from surface). This form of 3D representation is cross-compatible with 3D meshes, point-clouds, and depth maps. Analogous to 2D RGB pixel matrices for color images, 3D TDF voxel grids also provide a natural volumetric encoding of 3D space that is suitable as input to a 3D ConvNet. The TDF representation holds several advantages over its signed alternative TSDF [7], which encodes occluded space (values near −1) in addition to the surface (values near 0) and free space (values near 1). By removing the sign, the TDF loses the distinction between free space and occluded space, but gains a new property that is crucial to the robustness of our descriptor on partial data: the largest gradients between voxel values are concentrated around the surfaces rather than in the shadow boundaries between free space and occluded space. Furthermore, the TDF representation reduces the ambiguity of determining what is occluded space on 3D data where camera view is unavailable.
Figure 3. t-SNE embedding of 3DMatch descriptors for local 3D patches from the redkitchen test scene of 7-scenes [24]. This embedding suggests that our 3DMatch convnet is able to cluster local 3D patches based on local geometric features such as edges (a, f), Planes (e), Corners (c, d), and other geometric structures (g, b, h) In the face of noisy and partial data. 
4.2. Network Architecture: 3DMatch is a standard 3D ConvNet, inspired by AlexNet [9]. Given a 30×30×30 TDF voxel grid of a local 3D patch around an interest point, we use eight convolutional layers (each with a rectified linear unit activation function for nonlinearity) and a pooling layer to compute a 512-dimensional feature representation, which serves as the feature descriptor. Since the dimensions of the initial input voxel grid are small, we only include one layer of pooling to avoid a substantial loss of information. Convolution parameters are shown in Fig. 2 as (kernel size, number of filters). 4.3. Network Training: During training, our objective is to optimize the local descriptors generated by the ConvNet such that they are similar for 3D patches corresponding to the same point, and dissimilar otherwise. To this end, we train our ConvNet with two streams in a Siamese fashion where each stream independently computes a descriptor for a different local 3D patch. The first stream takes in the local 3D patch around a surface point p1, while the second stream takes in a second local 3D patch around a surface point p2. Both streams share the same architecture and underlying weights. We use the ℓ2 norm as a similarity metric between descriptors, modeled during training with the contrastive loss function [6]. This loss minimizes the ℓ2 distance between descriptors of corresponding 3D point pairs (matches), while pulling apart the ℓ2 distance between descriptors of non-corresponding 3D point pairs. During training, we feed the network with a balanced 1:1 ratio of matches to non-matches, a strategy which has shown to be effective for efficiently learning discriminative descriptors [16], [31], [40]. Fig. 3 shows a t-SNE embedding [37] of local 3D patches based on their 3DMatch descriptors, which demonstrates the ConvNet's ability to cluster local 3D patches based on their geometric structure as well as local context.
Figure 4. Which 3D patches are matched by 3DMatch? on the left, we show two fused fragments (A and B) taken at different scan view angles, as well as their registration result using 3DMatch + RANSAC. On the right, each row shows a local 3D patch from fragment A, followed by three nearest neighbor local 3D patches from fragment B found by 3DMatch descriptors. The bounding boxes are color coded to the keypoints illustrated on fragment A. 


SECTION 5. Evaluation: In this section, we first evaluate how well our learned local 3D descriptor (3DMatch) can match local 3D patches of interest point pairs (Sec. 5.1). We then evaluate its practical use as part of geometric registration for matching 3D data in several applications, such as scene reconstruction (Sec. 5.2) and 6D object pose estimation (Sec. 5.3). 5.1. Keypoint Matching: Our first set of experiments measure the quality of a 3D local descriptor by testing its ability to distinguish between matching and non-matching local 3D patches of keypoint pairs. Using the sampling algorithm described in Sec. 3, we construct a correspondence benchmark, similar to the Photo Tourism dataset [4] but with local 3D patches extracted from depth frames. The benchmark contains a collection of 30, 000 3D patches, with a 1:1 ratio between matches and non-matches. As in [4], [16], our evaluation metric is the false-positive rate (error) at 95% recall, the lower the better. Is Our Descriptor Better than Others?We compare our descriptor to several other state-of-the-art geometric descriptors on this correspondence benchmark. For Johnson et al. (Spin-Images) [18] and Rusu et al. (Fast Point Feature Histograms) [27], we use the implementation provided in the Point Cloud Library (PCL). While 3DMatch uses local TDF voxel grids computed from only a single depth frame, we run Johnson et al. and Rusu et al. on meshes fused from 50 nearby depth frames to boost their performance on this benchmark, since these algorithms failed to produce reasonable results on single depth frames. Nevertheless, 3DMatch outperforms these methods by a significant margin.
Table 1. Keypoint matching task error (%) at 95% recall.
What's the Benefit of 3D Volumes vs. 2D Depth Patches?We use TDF voxel grids to represent 3D data, not only because it is an intermediate representation that can be easily converted from meshes or point clouds, but also because this 3D representation allows reasoning over real-world spatial scale and occluded regions, which cannot be directly encoded in 2D depth patches. To evaluate the advantages of this 3D TDF encoding over 2D depth, we train a variant of our method using a 2D ConvNet on depth patches. The depth patches are extracted from a 0.3m3 crop and resized to 64×64 patches. For a fair comparison, the architecture of the 2D ConvNet is similar to our 3D ConvNet with two extra convolution layers to achieve a similar number of parameters as the 3D ConvNet. As shown in Table 1, this 2D ConvNet yields a higher error rate (38.5 vs. 35.3). Should We Use a Metric Network?Recent work [16] proposes the joint learning of a descriptor and similarity metric with ConvNets to optimize matching accuracy. To explore this idea, we replace our contrastive loss layer with three fully connected layers, followed by a Softmax layer for binary classification of “match” vs “non-match”. We evaluate the performance of this network on our keypoint matching benchmark, where we see an error of 33.1% (2.2% improvement). However, as noted by Yi et al. [40], descriptors that require a learned metric have a limited range of applicability due to the O(n2) comparison behaviour at test time since they cannot be directly combined with metric-based acceleration structures such as KD-trees. To maintain runtime within practical limits, we use the version of 3DMatch trained with an ℓ2 metric in the following sections. 5.2. Geometric Registration: To evaluate the practical use of our descriptor, we combine 3DMatch with a RANSAC search algorithm for geometric registration, and measure its performance on standard benchmarks. More specifically, given two 3D point clouds from scanning data, we first randomly sample n keypoints from each point cloud. Using the local 3D 30×30×30 TDF patches around each keypoint (aligned to the camera axes, which may be different per point cloud), we compute 3DMatch descriptors for all 2n keypoints. We find keypoints whose descriptors are mutually closest to each other in Euclidean space, and use RANSAC over the 3D positions of these keypoint matches to estimate a rigid transformation between the two point clouds.
Figure 5. Challenging cases of loop closures from test scenes of SUN3D [39]. In these instances, color features in the RGB images (top row) are insufficient for registering the scan pairs due to drastic viewpoint differences. While rusu et al. [27] fails at aligning the pairs (middle row), 3DMatch is able to successfully align each pair of scans (bottom row) by matching local geometric features. 
5.2.1 Matching Local Geometry in ScenesWe evaluate our 3DMatch-based geometric registration algorithm (i.e., 3DMatch + RANSAC) on both real and synthetic datasets. For synthetic, we use the benchmark from Choi et al. [5] which contains 207 fragments (each fused from 50 depth frames) of four scenes from the ICL-NUIM dataset [17]. However, the duplicated and over-simplified geometry in this ICL-NUIM dataset is very different from that of real-world scenes. Therefore, we create a separate benchmark with fragments formed from the testing split of our real-world reconstruction datasets. We use the same evaluation scheme introduced by Choi et al. [5], measuring the recall and precision of a method based on two factors: (1) how well it finds loop closures, and (2) how well it estimates rigid transformation matrices. Given two nonconsecutive scene fragments (Pi, Pj), the predicted relative rigid transformation Tij is a true positive if (1) over 30% of TijPi overlaps with Pj and if (2) Tij is sufficiently close to the ground-truth transformation T∗ij.Tij is correct if it brings the RMSE of the ground truth correspondences K∗ij between Pi and Pj below a threshold τ=0.2
1∣∣K∗ij∣∣∑(p∗,q∗)∈K∗ij∥Tijp∗−q∗∥2<τ2(1)View Source\begin{equation*}
\frac{1}{\left\vert K_{ij}^{\ast}\right\vert}\sum_{(p^{\ast}, q^{\ast})\in K_{ij}^{\ast}}\Vert T_{ij}p^{\ast}-q^{\ast}\Vert ^{2} < \tau^{2} \tag{1}
\end{equation*} where p∗ q∗ are the ground truth correspondences. Since the benchmark from Choi et al. [5] uses fragments fused from multiple depth frames, we fine-tune our 3DMatch ConvNet on correspondences over a set of fragments constructed in the same way using the 7-scenes training set. We then run pairwise geometric registration with 3DMatch + RANSAC on every pair of fragments from the benchmarks. We compare the performance of our 3DMatch-based registration approach versus other state-of-the-art geometric registration methods on the synthetic data benchmark in Table 2 [5], and the real data benchmark in Table 3. We also compare with Rusu et al. [27] and Johnson et al. [18] using the same RANSAC-based pipeline. Overall, our descriptor with RANSAC outperforms other methods by a significant margin on both datasets.
Table 2. Performance of geometric registration algorithms between fused fragments of synthetic scans.
Table 3. Performance of geometric registration algorithms between fused fragments of real-world scans.
Figure 6. 3DMatch for reconstructions. On the left, we show a complete reconstruction of an apartment from SUN3D [39] using only 3DMatch. On the right, we show two reconstructions using only SIFT to match color features (top), using only 3DMatch to match geometric features (middle), and using both SIFT and 3DMatch (bottom). The red boxes highlight areas with poor reconstruction quality, while the green boxes highlight areas with improved quality. These examples show that 3DMatch provides strong geometric feature correspondences that are complementary to color features and can help to improve the quality of reconstructions. 
5.2.2 Integrate 3DMatch in Reconstruction PipelineIn this section, we show that 3DMatch is not only capable of detecting challenging cases of loop closure, but also can be used in a standard reconstruction pipeline to generate high-quality reconstructions of new scenes. We use our 3DMatch descriptor as part of a standard sparse bundle adjustment formulation for scene reconstruction [35], [1]. Traditionally, sparse RGB features, such as SIFT or SURF, are used to establish feature matches between frames. With 3DMatch, we are able to establish keypoint matches from geometric information and add to the bundle adjustment step. With this simple pipeline we are able to generate globally-consistent alignments in challenging scenes using only geometric information as shown in Fig. 6. We also find that color and depth provide complementary information for RGB-D reconstructions. For example, sparse RGB features can provide correspondences where there is insufficient geometric information in the scans, while geometric signals are helpful where there are drastic viewpoint or lighting changes that cause traditional RGB features to fail. Fig. 5 shows challenging cases of loop closure from the testing split of the SUN3D datasets that are difficult for color-based descriptors to find correspondences due to drastic viewpoint differences. Our 3DMatch-based registration algorithm is capable of matching the local geometry to find correspondences and bring the scans into alignment. In Fig. 6, we show several reconstruction results where combining correspondences from both SIFT (color) and 3DMatch (geometry) improves alignment quality as a whole. 5.3. Can 3DMatch Generalize to New Domains?: As a final test, we evaluate the ability of our 3DMatch descriptor, which is trained from 3D reconstructions, to generalize to completely different tasks and spatial scales; namely, 6D object pose estimation by model alignment and correspondence labeling for 3D meshes. 6D Object Pose Estimation by Model AlignmentIn our first experiment, the task is to register pre-scanned object models to RGB-D scanning data for the Shelf & Tote benchmark in the Amazon Picking Challenge (APC) setting [42], as illustrated in Fig. 7. This scenario is different from scene level reconstruction in the following two aspects: (1) object sizes and their geometric features are much smaller in scale and (2) the alignment here is from full pre-scanned models to partial scan data, instead of partial scans to partial scans.
Table 4. Performance of geometric registration algorithms for model-fitting. Numbers are reported in terms of average % correct rotation and translation predictions.
To account for spatial scale differences, we reduce the size of each voxel to 0.005m3 within the local 3D patches. The voxel grids from the object models are aligned with respect to the object model's coordinates axes, while the voxel grids from the scans are aligned to the camera axes. We use the 3DMatch network pre-trained on reconstructions, and fine-tune it on a 50% training split of the Shelf & Tote data. Similar to how we align scene fragments to each other in Sec. 5.2, we use a RANSAC based geometric registration approach to align the object models to scans. The predicted rigid transformation is used as object pose. Similar to the baseline approach, we perform model alignment between object models to segmentation results from [42]. We evaluate on the testing split of the Shelf&Tote dataset using the error metric from [42], where we report the percentage of pose predictions with error in orientation smaller than 15° and translations smaller than 5cm. We compare to the baseline approach for the Shelf & Tote benchmark, as well as to other approaches in Table 4. Several of our predictions are illustrated in Fig. 8. Our descriptor significantly outperforms the baseline approach with over 10% improvement in rotation prediction accuracy and other registration variants. The 3DMatch model without pre-training on reconstructions yields a lower performance, demonstrating the importance of pre-training on reconstruction data.
Figure 7. 6D pose estimation in the amazon picking challenge by aligning object models (a) To scanning data (b). (c) Is a top-down view of the scanned shelf highlighting the noisy, partial nature of depth data from the RGB-D sensor. 
Figure 8. Predicted object poses on the shelf & tote benchmark using 3DMatch + RANSAC. Predicted object poses are shown on the images of the scans with 3D bounding boxes of the transformed object models. 3DMatch + RANSAC works well for many cases; however, it may fail when there is insufficient depth information due to occlusion or clutter (bottom). 
Surface Correspondence on 3D MeshesIn our final experiment, we test 3DMatch's ability to generalize even further to other modalities. We take a 3DMatch model trained on RGB-D reconstruction data, and directly test it on 3D mesh models without any fine-tuning to see whether 3DMatch is able to find surface correspondences based on local geometry. Given a query point on the surface of a 3D mesh, the goal is to find geometrically similar points on a second mesh (e.g. for transferring annotations about human contact points [19]). We do this by first encoding the local volumetric regions (with size 0.3m3) of the query point from the first mesh and all surface points from the second mesh into TDF volume aligned to object coordinate, and compute their 3DMatch descriptors. For every surface point on the second mesh, we color it with intensity based on its descriptor's ℓ2 distance to the descriptor of the query point. Fig. 9 shows results on meshes from the Shape2Pose dataset [19]. The results demonstrate that without any fine-tuning on the mesh data, 3DMatch can be used as a general 3D shape descriptor to find correspondences with similar local geometry between meshes. Interestingly 3DMatch is also able to find geometric correspondences across different object categories. For example in the third row of Fig. 9, 3DMatch is able to match the handles in very different meshes.
Figure 9. Surface correspondences on 3D meshes. The first column shows the input mesh and query points (red and blue). The other columns show the respective correspondences found in other meshes of the same object category (top and middle row) and across different object categories (bottom row). 


SECTION 6. Conclusion: In this work, we presented 3DMatch, a 3D ConvNet-based local geometric descriptor that can be used to match partial 3D data for a variety of applications. We demonstrated that by leveraging the vast amounts of correspondences automatically obtained from RGB-D reconstructions, we can train a powerful descriptor that outperforms existing geometric descriptors by a significant margin. We make all code and pre-trained models available for easy use and integration. To encourage further research, we also provide a correspondence matching benchmark and a surface registration benchmark, both with real-world 3D data. 
ACKNOWLEDGEMENTS: This work is supported by the NSF/Intel VEC program and Google Faculty Award. Andy Zeng is supported by the Gordon Y.S. Wu Fellowship. Shuran Song is supported by the Facebook Fellowship. Matthias Nießner is a member of the Max Planck Center for Visual Computing and Communications (MPC-VCC). We gratefully acknowledge the support of NVIDIA and Intel for hardware donations.