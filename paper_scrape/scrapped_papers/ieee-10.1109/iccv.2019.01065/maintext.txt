SECTION 1. Introduction: Humans are remarkably good at generalization. When given a picture of a previously unseen exotic animal, say, we can form a vivid mental picture of the same animal in a different pose, especially when we have encountered (images of) similar but different animals in that pose before. For example, a person seeing a standing tiger for the first time will have no trouble imagining what it will look lying down, given a lifetime of experience of other animals. While recent unsupervised image-to-image translation algorithms are remarkably successful in transferring complex appearance changes across image classes [28], [43], [26], [23], [51], [48], the capability to generalize from few samples of a new class based on prior knowledge is entirely beyond their reach. Concretely, they need large training sets over all classes of images they are to perform translation on, i.e., they do not support few-shot generalization. As an attempt to bridge the gap between human and machine imagination capability, we propose the Few-shot UN-supervised Image-to-image Translation (FUNIT) framework, aiming at learning an image-to-image translation model for mapping an image of a source class to an analogous image of a target class by leveraging few images of the target class given at test time. The model is never shown images of the target class during training but is asked to generate some of them at test time. To proceed, we first hypothesize that the few-shot generation capability of humans develops from their past visual experiences—a person can better imagine views of a new object if the person has seen many more different object classes in the past. Based on the hypothesis, we train our FUNIT model using a dataset containing images of many different object classes for simulating the past visual experiences. Specifically, we train the model to translate images from one class to another class by leveraging few example images of the another class. We hypothesize that by learning to extract appearance patterns from the few example images for the translation task, the model learns a generalizable appearance pattern extractor that can be applied to images of unseen classes at test time for the few-shot image-to-image translation task. In the experiment section, we give empirical evidence that the few-shot translation performance improves as the number of classes in the training set increases. Our framework is based on Generative Adversarial Networks (GAN) [13]. We show that by coupling an adversarial training scheme with a novel network design we achieve the desired few-shot unsupervised image-to-image translation capability. Through extensive experimental validation on three datasets, including comparisons to several baseline methods using a variety of performance metrics, we verify the effectiveness of our proposed framework. In addition, we show the proposed framework can be applied to the few-shot image classification task. By training a classifier on the images generated by our model for the few-shot classes, we are able to outperform a state-of-the-art few-shot classification method that is based on feature hallucination. 

SECTION 2. Related Work:  Figure 1. Training. The training set consists of images of various object classes (source classes). We train a model to translate images between these source object classes. Deployment. We show our trained model very few images of the target class, which is sufficient to translate images of source classes to analogous images of the target class even though the model has never seen a single image from the target class during training. Note that the FUNIT generator takes two inputs: 1) a content image and 2) a set of target class images. It aims to generate a translation of the input image that resembles images of the target class.  Unsupervised/unpaired image-to-image translation aims at learning a conditional image generation function that can map an input image of a source class to an analogues image of a target class without pair supervision. This problem is inherently ill-posed as it attempts to recover the joint distribution using samples from marginal distributions [26], [28]. To deal with the problem, existing works use additional constraints. For example, some works enforce the translation to preserve certain properties of the source data, such as pixel values [38], pixel gradients [5], semantic features [43], class labels [5], or pairwise sample distances [3]. There are works enforcing the cycle consistency constraint [48], [51], [23], [1], [52]. Several works use the shared/partially-shared latent space assumption [26], 28]/[18, 24]. Our work is based on the partiallyshared latent space assumption but is designed for the fewshot unsupervised image-to-image translation task. While capable of generating realistic translation outputs, existing unsupervised image-to-image translation models are limited in two aspects. First, they are sample inefficient, generating poor translation outputs if only few images are given at training time. Second, the learned models are limited for translating images between two classes. A trained model for one translation task cannot be directly reused for a new task despite similarity between the new task and the original task. For example, a husky-to-cat translation model can not be re-purposed for husky-to-tiger translation even though cat and tiger share a great similarity. Recently, Benaim and Wolf [4] proposed an unsupervised image-to-image translation framework for partially addressing the first aspect. Specifically, they use a training dataset consisting of one source class image but many target class images to train a model for translating the singlesource class image to an analogous image of the target class. Our work differs from their work in several major ways. First, we assume many source class images but few target class images. Moreover, we assume that the few target class images are only available at test time and can be from many different object classes. Multi-class unsupervised image-to-image translation [7], [2], [19] extends the unsupervised image-to-image translation methods to multiple classes. Our work is similar to these methods in the sense that our training dataset consists of images of multiple classes. But instead of translating images among seenclasses, we focus on translating images of seen classes to analogous images of previously unseenclasses. Few-shot classification. Unlike few-shot image-to-image translation, the task of learning classifiers for novel classes using few examples is a long-studied problem. Early works use generative models of appearance that share priors across classes in a hierarchical manner [10], [36]. More recent works focus on using meta-learning to quickly adapt models to novel tasks [11], [32], [35], [31]. These methods learn better optimization strategies for training, so that the performance upon seeing only few examples is improved. Another set of works focus on learning image embeddings that are better suited for few-shot learning [45], [40], [41]. Several recent works propose augmenting the training set for the few-shot classification task by generating new feature vectors corresponding to novel classes [9], [14], [47]. Our work is designed for few-shot unsupervised image-to-image translation. However, it can be applied to few-shot classification, as shown in the experiments section. 

SECTION 3. Few-Shot Unsupervised Image Translation: The proposed FUNIT framework aims at mapping an image of a source class to an analogous image of an unseen target class by leveraging a few target class images that are made available at test time. To train FUNIT, we use images from a set of object classes (e.g. images of various animal species), called the source classes. We do not assume existence of paired images between any two classes (i.e. no two animals of different species are at exactly the same pose). We use the source class images to train a multi-class unsupervised image-to-image translation model. During testing, we provide the model few images from a novel object class, called the target class. The model has to leverage the few target images to translate any source class image to analogous images of the target class. When we provide the same model few images from a different novel object class, it has to translate any source class images to analogous images of the different novel object class. Our framework consists of a conditional image generator G and a multi-task adversarial discriminator D. Unlike the conditional image generators in existing unsupervised image-to-image translation frameworks [51], [26], which take one image as input, our generator G simultaneously takes a content image x and a set of K class images {y1, yK} as input and produce the output image x¯¯¯ via
x¯¯¯=G(x, {y1, yK(1)View Source\begin{equation*}\overline{\mathrm{x}}=G(\mathrm{x},\ \{\mathrm{y}_{1},\ \mathrm{y}_{K} \tag{1}\end{equation*} We assume the content image belongs to object class cx while each of the K class images belong to object class cy. In general, K is a small number and cx is different from cy. We will refer G as the few-shot image translator. As shown in Figure 1, G maps an input content image x to an output image x¯¯¯, such that x¯¯¯ looks like an image belonging to object class cy, and x¯¯¯ and x share structural similarity. Let S and T denote the set of source classes and the set of target classes, respectively. During training, G learns to translate images between two randomly sampled source classes cx,cy∈S with cx≠cy. At test time, G takes a few images from an unseen target class c∈F as the class images, and maps an image sampled from any of the source classes to an analogous image of the target class c. Next, we discuss the network design and learning. More details are available in our full technical paper [27]. 3.1. Few-shot Image Translator: The few-shot image translator G consists of a content encoder Ex, a class encoder Ey, and a decoder Fx. The content encoder is made of several 2D convolutional layers followed by several residual blocks [15], [20]. It maps the input content image x to a content latent code zx, which is a spatial feature map. The class encoder consists of several 2D convolutional layers followed by a mean operation along the sample axis. Specifically, it first maps each of the K individual class images {y1, yK} to an intermediate latent vector and then computes the mean of the intermediate latent vectors to obtain the final class latent code zy. The decoder consists of several adaptive instance normalization (AdaIN) residual blocks [18] followed by a couple of upscale convolutional layers. The AdaIN residual block is a residual block using the AdaIN [17] as the normalization layer. For each sample, AdaIN first normalizes the activations of a sample in each channel to have a zero mean and unit variance. It then scales the activations using a learned affine transformation consisting of a set of scalars and biases. Note that the affine transformation is spatially invariant and hence can only be used to obtain global appearance information. The affine transformation parameters are adaptively computed using zy via a two-layer fully connected network. With Ex,Ey, and Fx, (1) becomes
x¯¯¯=Fx(zx, zy)=Fx(Ex(x),Ey({y1,yK.(2)View Source\begin{equation*}\overline{\mathrm{x}}=F_{x}(\mathrm{z}_{x},\ \mathrm{z}_{y}) =F_{x}(E_{x}(\mathrm{x}), E_{y}(\{\mathrm{y}_{1}, \mathrm{y}_{K}. \tag{2}\end{equation*} By using this translator design, we aim at extracting class-invariant latent representation (e.g., object pose) using the content encoder and extracting class-specific latent representation (e.g., object appearance) using the class encoder. By feeding the class latent code to the decoder via the AdaIN layers, we let the class images control the global look (e.g., object appearance), while the content image determines the local structure (e.g., locations of eyes). At training time, the class encoder learns to extract class-specific latent representation from the images of the source classes. At test time, this generalizes to images of previously unseen classes. In the experiment section, we show that the generalization capability depends on the number of source object classes seen during training. When G is trained with more source classes (e.g., more species of animals), it has a better few-shot image translation performance (e.g., better in translating husky to mountain lion). 3.2. Multi-task Adversarial Discriminator: Our discriminator D is trained by solving multiple adversarial classification tasks simultaneously. Each of the tasks is a binary classification task determining whether an input image is a real image of the source class or a translation output coming from G. As there are |S| source classes, D produces |S| outputs. When updating D for a real image of source class cx, we penalize D if its cxth output is false. For a translation output yielding a fake image of source class cx, we penalize D if its cxth output is positive. We do not penalize D for not predicting false for images of other classes (S∖{cx}). When updating G, we only penalize G if the cxth output of D is false. We empirically find this discriminator works better than a discriminator trained by solving a much harder |S|-class classification problem. 3.3. Learning: We train the proposed FUNIT framework by solving a minimax optimization problem given by
minDmaxGLGAN(D, G)+λRLR(G)+λFLFM(G)(3)View Source\begin{equation*}\displaystyle \min_{D}\max_{G}\mathcal{L}_{\mathrm{G}\mathrm{A}\mathrm{N}}(D,\ G)+\lambda_{\mathrm{R}}\mathcal{L}_{\mathrm{R}}(G)+\lambda_{\mathrm{F}}\mathcal{L}_{\mathrm{F}\mathrm{M}}(G) \tag{3}\end{equation*}
where LGAN,LR, and LF are the GAN loss, the content image reconstruction loss, and the feature matching loss. The GAN loss is a conditional one given by
LGAN(G, D)=Ex [− logDcx(x)]+Ex,{y1,…,yK}[log(1−Dcy(x¯¯¯)](4)View Source\begin{equation*}\mathcal{L}_{\mathrm{G}\mathrm{A}\mathrm{N}}(G,\ D)=E_{\mathrm{x}}\ [-\ \log D^{c_{x}}(\mathrm{x})]+E_{\mathrm{x},\{\mathrm{y}_{1},\ldots,\mathrm{y}_{K}\}}[\log(1-D^{c_{y}}(\overline{\mathrm{x}})] \tag{4}\end{equation*}
Table 1 Performance Comparison with the Fair and Unfair Baselines. ↑ Means Larger Numbers Are Better, ↓ Means Smaller Numbers Are Better.
The superscript attached to D denotes the object class; the loss is computed only using the corresponding binary prediction score of the class. The content reconstruction loss helps G learn a translation model. Specifically, when using the same image for both the input content image and the input class image (in this case K=1), the loss encourages G to generate an output image identical to the input
LR(G)=Ex[||x−G(x, {x})||11].(5)View Source\begin{equation*}\mathcal{L}_{\mathrm{R}}(G)=E_{\mathrm{x}}[||\mathrm{x}-G(\mathrm{x},\ \{\mathrm{x}\})||_{1}^{1}]. \tag{5}\end{equation*} The feature matching loss regularizes the training. We first construct a feature extractor, referred to as Df, by removing the last (prediction) layer from D. We then use Df to extract features from the translation output x¯¯¯ and the class images {y1, yK} and minimize
LF(G)=Ex,{y1,…,yK}[∥Df(x¯¯¯))−∑kDf(yk)K∥11](6)View Source\begin{equation*}\left.\mathcal{L}_{\mathrm{F}}\left(G\right)=E_{\mathrm{x},\left\{\mathrm{y}_{1}, \ldots, \mathrm{y}_{K}\right\}}\left[\| D_{f}\left(\overline{\mathrm{x}}\right)\right)-\sum_{k} \frac{D_{f}\left(\mathrm{y}_{k}\right)}{K} \|_{1}^{1}\right]\tag{6}\end{equation*} Both of the content reconstruction loss and the feature matching loss are not new topics to image-to-image translation [26], [18], [46], [34]. Our contribution is in extending their use to the more challenging and novel few-shot unsupervised image-to-image translation setting. 

SECTION 4. Experiments: Implementation. We set λR=0.1 and λF=1. We optimize (3) using RMSProp with learning rate 0.0001. We use the hinge version of GAN loss [25], [30], [49], [6] and the real gradient penalty regularization proposed by Mescheder et al. [29]. The final generator is a historical average version of the intermediate generators [21] where the update weight is 0.001. We train the FUNIT model using K=1 since we desire it to work well even when only one target class image is available at test time. In the experiments, we evaluate its performance under K=1, 5, 10, 15, 20. Each training batch consists of 64 content images, which are evenly distributed on 8 V100 GPUs in an NVIDIA DGXI machine. Datasets. We use the following datasets for experiments.
Figure 2. Visualization of the few-shot unsupervised image-to-image translation results. The results are computed using the FUNIT-5 model. From top to bottom, we have the results from the animal face, bird, flower, and food datasets. We train one model for each dataset. For each example, we visualize 2 out of 5 randomly sampled class images y1y2, the input content image x, and the translation output x¯¯¯. The results show that FUNIT generate plausible translation outputs under the difficult few-shot setting where the models see no images from any of the target classes during training. We note that the objects in the output images have similar poses to the inputs. 
Animal Faces. We build this dataset using images from the 149 carnivorous animal classes in ImageNet [8]. We first manually label bounding boxes of 10000 carnivorous animal faces in the images. We then train a Faster RCNN [12] to detect animal faces in the images. We only use the bounding boxes with high detection scores. This renders a set of 117574 animal faces. We split the classes into a source class set and a target class set, which contains 119 and 30 animal classes, respectively. Birds [44]. 48527 images of 555 North American bird species. 444 species are used for the source class set and 111 species are used for the target class set. Flowers [33]. 8189 images from 102 species. The source and target sets have 85 and 17 species, respectively. Foods [22]. 31395 images from 256 kinds of food. The source and target set have 224 and 32 kinds, respectively.  Baselines. Depending on whether images of the target class are available during training, we define two sets of baselines: fair (unavailable) and unfair (available).
Fair. This is the setting of the proposed FUNIT framework. As none of the prior unsupervised image-to-image translation methods are designed for the setting, we build a baseline by extending the StarGAN method [7], which is the state of the art for multi-class unsupervised image-to-image translation. We train a StarGAN model purely using source class images. During testing, given K images of a target class, we compute the average VGG [39] Conv5 features for the K images and compute its cosine distance to the average VGG Conv5 feature for the images of each source class. We then compute the class association vector by applying softmax to the cosine distances. We use the class association vector as input to the StarGAN model (substituting the one-hot class association vector input) for generating images of unseen target classes. The baseline method is designed with the assumption that the class association scores could encode how an unseen target object class is related to each of the source classes, which can be used for few-shot generation. We denote this baseline StarGAN-Fair-K. Unfair. These baselines include target class images in the training. We vary the number of available images (K) per target class from 1 to 20 and train various unsupervised image-to-image translation models. We denote the StarGAN model that is trained with K images per target class as StarGAN-Unfair-K. We also train several state-of-the-art two-domain translation models including CycleGAN [51], UNIT [26], and MUNIT [18]. For them, we treat images of the source classes as the first domain and images of one target class as the second domain. This results in |F| unsupervised image-to-image translation models per dataset per two-class baseline. We label these baselines as CycleGAN-Unfair-K, UNIT-Unfair-K, and MUNIT-Unfair-K.  For the baseline methods, we use the source code and de-fault parameter settings provided by the authors.
Figure 3. Visual comparison of few-shot image-to-image translation performance. From left to right, the columns are input content images x, the two input target class images y1y2, translation results from the unfair ScarGiaN baseline, translation results from the fair SCarGiaN baseline, and results from our framework.  Evaluation protocol. We use a randomly sampled 25000 images from the source classes as the content images. We then translate them to each target class by randomly sample K images of the target class. This produces |F| sets of images for each competing approach and they are used for evaluation. We use the same K images for each content image for all the competing approaches. We test a range of K values, including 1, 5, 10, 15, and 20. Performance metrics. We use several criteria for evaluation. First, we measure whether translations resemble images of the target class. Second, we examine whether class-invariant content are preserved during translation. Third, we quantify photorealism of output images. Finally, we measure whether the model can be used to generate the image distribution of a target class. We briefly describe our performance metrics for these criteria below and leave their details in our full technical paper [27].
Translation accuracy measure whether a translation output belongs to the target class. We use two InceptionV3 [42] classifiers. One classifier is trained using both of the source and target classes (denoted as all), while the other is trained using the target classes along (denoted as test). We report both Top1 and Top5 accuracies. Content preservation is based on a variant of perceptual distance [20], [50], called the domain-invariant perceptual distance (DIPD) [18]. The distance is given by L2 distance between two normalized VGG [39] Conv5 features, which is more invariant against domain change [18]. Photorealism. This is measured by the inception scores (IS) [37]. We report inception scores using the two inception classifiers trained for measuring translation accuracy, denoted by all and test, respectively. Distribution matching is based on Fréchet Inception Distance (FID) [16]. We compute FID for each of the |T| target object classes and report their mean FID (mFID).  Main results. As shown in Table 1, the proposed FUNIT framework outperforms the baselines for the few-shot unsupervised image-to-image translation task on all the performance metrics for both the Animal Faces and North American Birds datasets. F UNIT achieves 82.36 and 96.05 Top-5 (test) accuracy for the 1-shot and 5-shot settings, respectively, on the Animal Face dataset, and 60.19 and 75.75 on the North American Birds dataset. They are all significantly better than those achieved by the corresponding fair baselines. Similar trends can be found for the domain invariant perceptual distance, inception score, and Fréchet inception distance. Moreover, with just 5 shots, FUNIT outperforms all the unfair baselines under 20-shot settings. Note that for the results of CycleGAN-Unfair-20, UNIT-Unfair-20, and MUNIT-Unfair-20 are from |F| image-to-image translation networks, while our method is from a single translation network. The table also shows that the performance of the proposed FUNIT model is positively correlated with number of available target images K at test time. A larger K leads to improvements across all the metrics, and the largest performance boost comes from K=1 to K=5. The StarGAN-Fair baseline does not exhibit a similar trend. In Figure 2, we visualize the few-shot translation results computed by FUNIT 5. The results show that the FUNIT model can successfully translate images of source classes to analogous images of novel classes. The poses of the object in the input content image x and the corresponding output image x¯¯¯ remain largely the same. The output images are photorealistic and resemble images from the target classes. In Figure 3, we provide a visual comparison. As the baselines are not designed for the few-shot image translation setting, they failed in the challenging translation task. They either generate images with a large amount of artifacts or just output the input content image. On the other hand, FUNIT generates high-quality image translation outputs. User study. To compare the photorealism and faithfulness of the translation outputs, we perform human evaluation using the Amazon Mechanical Turk (AMT) platform. Specifically, we give the workers a target class image and two translation outputs from different methods [46], [18] and ask them to choose the output image that resembles more the target class image. The workers are given unlimited time to make the selection. We use both the Animal Faces and North American Birds datasets. For each comparison, we randomly generate 500 questions and each question is answered by 5 different workers. For quality control, a worker must have a lifetime task approval rate grater than 98% to be able to participate in the evaluation.
Table 2 User Preference Score. the Numbers Indicate the Percentage of Users Favors Results Generated By the Proposed Method Over Those Generated By the Competing Method.
Table 3 Few-Shot Classification Accuracies Averaged Over 5 Splits. According to Table 2, the human subjects consider the translation outputs generated by the proposed method under the 5-shot setting (FUNIT-5) much more similar to the target class images than those generate by the fair baseline under the same setting (StarGAN-Fair-5). Even when compared with the results of unfair baselines that have access to 20 images per target class at training time, our translation results are still considered to be much more faithful. Number of source classes in the training set. In Figure 4, we analyze the performance versus varying number of source classes in the training set under the one-shot setting (FUNIT-1), using the animal dataset. We plot the curves by varying the number from 69 to 119 classes with an interval of 10. As shown, the performance is positively correlated with the number of object classes in terms of translation accuracy, image quality, and distribution matching. The domain-invariant perceptual distance remains flat. This shows that a FUNIT model that sees more object classes (larger diversity) during training performs better during testing. A similar trend is observed for the bird dataset, which is given in our full technical paper [27]. Comparison to AdaIN. We train an AdaIN style transfer network [17] for the few-shot animal face translation task and compare the results to ours. The visual comparison is given in the full technical report [27]. While the style transfer network can change the textures of the input animals, it does not change their shapes. As a result, the translation outputs still resemble to the inputs.
Figure 4. Few-shot image translation performance vs. number of object classes seen during training on the Animal Faces dataset. The performance is positively correlated with number of source object classes seen during training. 
Figure 5. Limitations of the proposed framework. When the appearance of a unseen object class is dramatically different to the appearances of the source classes, (e.g. flower and animal face). The proposed FUNIT framework fails to generate meaningful translation outputs.  Parameter analysis and ablation study. We analyze the impact of the individual terms in our objective function and find all of them are essential. Particularly, the content reconstruction loss trades translation accuracies for content preservation score. Supporting experiment results are given in our full technical paper [27]. Latent interpolation. In our full technical paper [27], we show interpolation results by keeping the content code fixed while interpolating the class code between those of two source class images. Interestingly, we find that by interpolating between two source classes (Siamese cat and Tiger) we can sometimes generate a target class (Tabby cat) that the model has never observed. Failure cases. Several failure cases of the proposed algorithm are visualized in our full technical paper [27]. They include generating hybrid objects, ignoring input content images, and ignoring input class images. Few-shot translation for few-shot classification. We evaluate FUNIT for few-shot classification using the animal and bird datasets. Specifically, we use the trained FUNIT models to generate N (varying from 1, 50, to 100) images for each of the few-shot classes and use the generated images to train the classifiers. We find the classifiers trained with the FUNIT generated images consistently achieve better performance than the few-shot classification approach proposed of S&H by Hariharan et al. [14], which is based on feature hallucination and also has a controllable variable on sample number N. The results are shown in Table 3 and the experiment details are in our full technical paper [27]. 

SECTION 5. Discussion and Future Work: We introduced the first few-shot unsupervised image-to-image translation framework. We showed that the few-shot generation performance is positively correlated with the number of object classes seen during training and also positively correlated with the number of target class shots provided during test time. We provided empirical evidence that FUNIT can learn to translate an image of a source class to a corresponding image of an unseen object class by utilizing few example images of the unseen class made available at test time. Although achieving this new capability, FUNIT depends on several conditions to work: 1) whether the content encoder Ex can learn a class-invariant latent code zx, 2) whether the class encoder Ey can learn a class-specific latent code zy, and, most importantly, 3) whether the class encoder Ey can generalize to images of unseen object classes. We observed these conditions are easy to meet when the novel classes are visually related to the source classes. However, when the appearance of novel object classes are dramatically different from those of the source classes, FUNIT fails to achieve translation as shown in Figure 5. In this case, FUNIT tends to generate color-changed versions of the input content images. This is undesirable but understandable as the appearance distribution has changed dramatically. Addressing this limitation is our future work.